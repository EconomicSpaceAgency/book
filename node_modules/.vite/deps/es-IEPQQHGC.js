"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  __require,
  __toESM,
  require_dist
} from "./chunk-VJXJXNP7.js";

// node_modules/@web3-onboard/magic/node_modules/magic-sdk/dist/es/index.mjs
var import_dist4 = __toESM(require_dist(), 1);

// node_modules/@web3-onboard/magic/node_modules/@magic-sdk/provider/dist/es/index.mjs
var import_dist2 = __toESM(require_dist(), 1);

// node_modules/@web3-onboard/magic/node_modules/@magic-sdk/types/dist/es/index.mjs
var import_dist = __toESM(require_dist(), 1);
var a = ((n) => (n.MissingApiKey = "MISSING_API_KEY", n.ModalNotReady = "MODAL_NOT_READY", n.MalformedResponse = "MALFORMED_RESPONSE", n.InvalidArgument = "INVALID_ARGUMENT", n.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", n.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", n))(a || {});
var m = ((_2) => (_2.SyncWeb3Method = "SYNC_WEB3_METHOD", _2.DuplicateIframe = "DUPLICATE_IFRAME", _2.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", _2.DeprecationNotice = "DEPRECATION_NOTICE", _2))(m || {});
var p = ((e) => (e[e.ParseError = -32700] = "ParseError", e[e.InvalidRequest = -32600] = "InvalidRequest", e[e.MethodNotFound = -32601] = "MethodNotFound", e[e.InvalidParams = -32602] = "InvalidParams", e[e.InternalError = -32603] = "InternalError", e[e.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", e[e.MagicLinkExpired = -10001] = "MagicLinkExpired", e[e.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", e[e.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", e[e.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", e[e.UpdateEmailFailed = -10004] = "UpdateEmailFailed", e[e.UserRequestEditEmail = -10005] = "UserRequestEditEmail", e[e.InactiveRecipient = -10010] = "InactiveRecipient", e[e.AccessDeniedToUser = -10011] = "AccessDeniedToUser", e))(p || {});
var o = ((t) => (t.LoginWithSms = "magic_auth_login_with_sms", t.LoginWithEmailOTP = "magic_auth_login_with_email_otp", t.LoginWithMagicLink = "magic_auth_login_with_magic_link", t.LoginWithCredential = "magic_auth_login_with_credential", t.GetIdToken = "magic_auth_get_id_token", t.GenerateIdToken = "magic_auth_generate_id_token", t.GetMetadata = "magic_auth_get_metadata", t.IsLoggedIn = "magic_auth_is_logged_in", t.Logout = "magic_auth_logout", t.UpdateEmail = "magic_auth_update_email", t.UserSettings = "magic_auth_settings", t.UserSettingsTestMode = "magic_auth_settings_testing_mode", t.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", t.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", t.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", t.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", t.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", t.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", t.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", t.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", t.LogoutTestMode = "magic_auth_logout_testing_mode", t.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", t))(o || {});
var u = ((i) => (i.MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", i.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", i.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", i.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", i.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", i))(u || {});
var g = ((s) => (s.MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", s))(g || {});
var l = ((s) => (s.Harmony = "HARMONY", s))(l || {});

// node_modules/@web3-onboard/magic/node_modules/@magic-sdk/provider/dist/es/index.mjs
var yt = Object.create;
var U = Object.defineProperty;
var Rt = Object.defineProperties;
var Tt = Object.getOwnPropertyDescriptor;
var vt = Object.getOwnPropertyDescriptors;
var xt = Object.getOwnPropertyNames;
var be = Object.getOwnPropertySymbols;
var It = Object.getPrototypeOf;
var Me = Object.prototype.hasOwnProperty;
var Pt = Object.prototype.propertyIsEnumerable;
var Ne = (t, e, n) => e in t ? U(t, e, { enumerable: true, configurable: true, writable: true, value: n }) : t[e] = n;
var z = (t, e) => {
  for (var n in e || (e = {}))
    Me.call(e, n) && Ne(t, n, e[n]);
  if (be)
    for (var n of be(e))
      Pt.call(e, n) && Ne(t, n, e[n]);
  return t;
};
var we = (t, e) => Rt(t, vt(e));
var $t = (t) => U(t, "__esModule", { value: true });
var bt = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var Mt = (t, e) => {
  for (var n in e)
    U(t, n, { get: e[n], enumerable: true });
};
var Nt = (t, e, n, r) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s of xt(e))
      !Me.call(t, s) && (n || s !== "default") && U(t, s, { get: () => e[s], enumerable: !(r = Tt(e, s)) || r.enumerable });
  return t;
};
var wt = (t, e) => Nt($t(U(t != null ? yt(It(t)) : {}, "default", !e && t && t.__esModule ? { get: () => t.default, enumerable: true } : { value: t, enumerable: true })), t);
var I = (t, e, n) => new Promise((r, s) => {
  var o2 = (c) => {
    try {
      i(n.next(c));
    } catch (p2) {
      s(p2);
    }
  }, a2 = (c) => {
    try {
      i(n.throw(c));
    } catch (p2) {
      s(p2);
    }
  }, i = (c) => c.done ? r(c.value) : Promise.resolve(c.value).then(o2, a2);
  i((n = n.apply(t, e)).next());
});
var nt = bt((fr, fe) => {
  "use strict";
  var $n = Object.prototype.hasOwnProperty, T = "~";
  function B() {
  }
  Object.create && (B.prototype = /* @__PURE__ */ Object.create(null), new B().__proto__ || (T = false));
  function bn(t, e, n) {
    this.fn = t, this.context = e, this.once = n || false;
  }
  function tt2(t, e, n, r, s) {
    if (typeof n != "function")
      throw new TypeError("The listener must be a function");
    var o2 = new bn(n, r || t, s), a2 = T ? T + e : e;
    return t._events[a2] ? t._events[a2].fn ? t._events[a2] = [t._events[a2], o2] : t._events[a2].push(o2) : (t._events[a2] = o2, t._eventsCount++), t;
  }
  function oe(t, e) {
    --t._eventsCount === 0 ? t._events = new B() : delete t._events[e];
  }
  function y() {
    this._events = new B(), this._eventsCount = 0;
  }
  y.prototype.eventNames = function() {
    var e = [], n, r;
    if (this._eventsCount === 0)
      return e;
    for (r in n = this._events)
      $n.call(n, r) && e.push(T ? r.slice(1) : r);
    return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(n)) : e;
  };
  y.prototype.listeners = function(e) {
    var n = T ? T + e : e, r = this._events[n];
    if (!r)
      return [];
    if (r.fn)
      return [r.fn];
    for (var s = 0, o2 = r.length, a2 = new Array(o2); s < o2; s++)
      a2[s] = r[s].fn;
    return a2;
  };
  y.prototype.listenerCount = function(e) {
    var n = T ? T + e : e, r = this._events[n];
    return r ? r.fn ? 1 : r.length : 0;
  };
  y.prototype.emit = function(e, n, r, s, o2, a2) {
    var i = T ? T + e : e;
    if (!this._events[i])
      return false;
    var c = this._events[i], p2 = arguments.length, l2, u2;
    if (c.fn) {
      switch (c.once && this.removeListener(e, c.fn, void 0, true), p2) {
        case 1:
          return c.fn.call(c.context), true;
        case 2:
          return c.fn.call(c.context, n), true;
        case 3:
          return c.fn.call(c.context, n, r), true;
        case 4:
          return c.fn.call(c.context, n, r, s), true;
        case 5:
          return c.fn.call(c.context, n, r, s, o2), true;
        case 6:
          return c.fn.call(c.context, n, r, s, o2, a2), true;
      }
      for (u2 = 1, l2 = new Array(p2 - 1); u2 < p2; u2++)
        l2[u2 - 1] = arguments[u2];
      c.fn.apply(c.context, l2);
    } else {
      var v = c.length, M;
      for (u2 = 0; u2 < v; u2++)
        switch (c[u2].once && this.removeListener(e, c[u2].fn, void 0, true), p2) {
          case 1:
            c[u2].fn.call(c[u2].context);
            break;
          case 2:
            c[u2].fn.call(c[u2].context, n);
            break;
          case 3:
            c[u2].fn.call(c[u2].context, n, r);
            break;
          case 4:
            c[u2].fn.call(c[u2].context, n, r, s);
            break;
          default:
            if (!l2)
              for (M = 1, l2 = new Array(p2 - 1); M < p2; M++)
                l2[M - 1] = arguments[M];
            c[u2].fn.apply(c[u2].context, l2);
        }
    }
    return true;
  };
  y.prototype.on = function(e, n, r) {
    return tt2(this, e, n, r, false);
  };
  y.prototype.once = function(e, n, r) {
    return tt2(this, e, n, r, true);
  };
  y.prototype.removeListener = function(e, n, r, s) {
    var o2 = T ? T + e : e;
    if (!this._events[o2])
      return this;
    if (!n)
      return oe(this, o2), this;
    var a2 = this._events[o2];
    if (a2.fn)
      a2.fn === n && (!s || a2.once) && (!r || a2.context === r) && oe(this, o2);
    else {
      for (var i = 0, c = [], p2 = a2.length; i < p2; i++)
        (a2[i].fn !== n || s && !a2[i].once || r && a2[i].context !== r) && c.push(a2[i]);
      c.length ? this._events[o2] = c.length === 1 ? c[0] : c : oe(this, o2);
    }
    return this;
  };
  y.prototype.removeAllListeners = function(e) {
    var n;
    return e ? (n = T ? T + e : e, this._events[n] && oe(this, n)) : (this._events = new B(), this._eventsCount = 0), this;
  };
  y.prototype.off = y.prototype.removeListener;
  y.prototype.addListener = y.prototype.on;
  y.prefixed = T;
  y.EventEmitter = y;
  typeof fe != "undefined" && (fe.exports = y);
});
function At(t) {
  let e = { exports: {} };
  return t(e, e.exports), e.exports;
}
var Lt = Number.MAX_SAFE_INTEGER || 9007199254740991;
var me = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Lt, MAX_SAFE_COMPONENT_LENGTH: 16 };
var St = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var d = St;
var K = At(function(t, e) {
  let { MAX_SAFE_COMPONENT_LENGTH: n } = me, r = (e = t.exports = {}).re = [], s = e.src = [], o2 = e.t = {}, a2 = 0, i = (c, p2, l2) => {
    let u2 = a2++;
    d(u2, p2), o2[c] = u2, s[u2] = p2, r[u2] = new RegExp(p2, l2 ? "g" : void 0);
  };
  i("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i("MAINVERSION", `(${s[o2.NUMERICIDENTIFIER]})\\.(${s[o2.NUMERICIDENTIFIER]})\\.(${s[o2.NUMERICIDENTIFIER]})`), i("MAINVERSIONLOOSE", `(${s[o2.NUMERICIDENTIFIERLOOSE]})\\.(${s[o2.NUMERICIDENTIFIERLOOSE]})\\.(${s[o2.NUMERICIDENTIFIERLOOSE]})`), i("PRERELEASEIDENTIFIER", `(?:${s[o2.NUMERICIDENTIFIER]}|${s[o2.NONNUMERICIDENTIFIER]})`), i("PRERELEASEIDENTIFIERLOOSE", `(?:${s[o2.NUMERICIDENTIFIERLOOSE]}|${s[o2.NONNUMERICIDENTIFIER]})`), i("PRERELEASE", `(?:-(${s[o2.PRERELEASEIDENTIFIER]}(?:\\.${s[o2.PRERELEASEIDENTIFIER]})*))`), i("PRERELEASELOOSE", `(?:-?(${s[o2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[o2.PRERELEASEIDENTIFIERLOOSE]})*))`), i("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i("BUILD", `(?:\\+(${s[o2.BUILDIDENTIFIER]}(?:\\.${s[o2.BUILDIDENTIFIER]})*))`), i("FULLPLAIN", `v?${s[o2.MAINVERSION]}${s[o2.PRERELEASE]}?${s[o2.BUILD]}?`), i("FULL", `^${s[o2.FULLPLAIN]}$`), i("LOOSEPLAIN", `[v=\\s]*${s[o2.MAINVERSIONLOOSE]}${s[o2.PRERELEASELOOSE]}?${s[o2.BUILD]}?`), i("LOOSE", `^${s[o2.LOOSEPLAIN]}$`), i("GTLT", "((?:<|>)?=?)"), i("XRANGEIDENTIFIERLOOSE", `${s[o2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), i("XRANGEIDENTIFIER", `${s[o2.NUMERICIDENTIFIER]}|x|X|\\*`), i("XRANGEPLAIN", `[v=\\s]*(${s[o2.XRANGEIDENTIFIER]})(?:\\.(${s[o2.XRANGEIDENTIFIER]})(?:\\.(${s[o2.XRANGEIDENTIFIER]})(?:${s[o2.PRERELEASE]})?${s[o2.BUILD]}?)?)?`), i("XRANGEPLAINLOOSE", `[v=\\s]*(${s[o2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o2.XRANGEIDENTIFIERLOOSE]})(?:${s[o2.PRERELEASELOOSE]})?${s[o2.BUILD]}?)?)?`), i("XRANGE", `^${s[o2.GTLT]}\\s*${s[o2.XRANGEPLAIN]}$`), i("XRANGELOOSE", `^${s[o2.GTLT]}\\s*${s[o2.XRANGEPLAINLOOSE]}$`), i("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), i("COERCERTL", s[o2.COERCE], true), i("LONETILDE", "(?:~>?)"), i("TILDETRIM", `(\\s*)${s[o2.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", i("TILDE", `^${s[o2.LONETILDE]}${s[o2.XRANGEPLAIN]}$`), i("TILDELOOSE", `^${s[o2.LONETILDE]}${s[o2.XRANGEPLAINLOOSE]}$`), i("LONECARET", "(?:\\^)"), i("CARETTRIM", `(\\s*)${s[o2.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", i("CARET", `^${s[o2.LONECARET]}${s[o2.XRANGEPLAIN]}$`), i("CARETLOOSE", `^${s[o2.LONECARET]}${s[o2.XRANGEPLAINLOOSE]}$`), i("COMPARATORLOOSE", `^${s[o2.GTLT]}\\s*(${s[o2.LOOSEPLAIN]})$|^$`), i("COMPARATOR", `^${s[o2.GTLT]}\\s*(${s[o2.FULLPLAIN]})$|^$`), i("COMPARATORTRIM", `(\\s*)${s[o2.GTLT]}\\s*(${s[o2.LOOSEPLAIN]}|${s[o2.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", i("HYPHENRANGE", `^\\s*(${s[o2.XRANGEPLAIN]})\\s+-\\s+(${s[o2.XRANGEPLAIN]})\\s*$`), i("HYPHENRANGELOOSE", `^\\s*(${s[o2.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[o2.XRANGEPLAINLOOSE]})\\s*$`), i("STAR", "(<|>)?=?\\s*\\*"), i("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), i("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
var Ae = /^[0-9]+$/;
var Le = (t, e) => {
  let n = Ae.test(t), r = Ae.test(e);
  return n && r && (t = +t, e = +e), t === e ? 0 : n && !r ? -1 : r && !n ? 1 : t < e ? -1 : 1;
};
var Ot = (t, e) => Le(e, t);
var Ct = { compareIdentifiers: Le, rcompareIdentifiers: Ot };
var { MAX_LENGTH: Se, MAX_SAFE_INTEGER: Y } = me;
var { re: Oe, t: Ce } = K;
var { compareIdentifiers: j } = Ct;
var E = class {
  constructor(e, n) {
    if (n && typeof n == "object" || (n = { loose: !!n, includePrerelease: false }), e instanceof E) {
      if (e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid Version: ${e}`);
    if (e.length > Se)
      throw new TypeError(`version is longer than ${Se} characters`);
    d("SemVer", e, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    let r = e.trim().match(n.loose ? Oe[Ce.LOOSE] : Oe[Ce.FULL]);
    if (!r)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > Y || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Y || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Y || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        let o2 = +s;
        if (o2 >= 0 && o2 < Y)
          return o2;
      }
      return s;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (d("SemVer.compare", this.version, this.options, e), !(e instanceof E)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new E(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof E || (e = new E(e, this.options)), j(this.major, e.major) || j(this.minor, e.minor) || j(this.patch, e.patch);
  }
  comparePre(e) {
    if (e instanceof E || (e = new E(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let n = 0;
    do {
      let r = this.prerelease[n], s = e.prerelease[n];
      if (d("prerelease compare", n, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r !== s)
        return j(r, s);
    } while (++n);
  }
  compareBuild(e) {
    e instanceof E || (e = new E(e, this.options));
    let n = 0;
    do {
      let r = this.build[n], s = e.build[n];
      if (d("prerelease compare", n, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r !== s)
        return j(r, s);
    } while (++n);
  }
  inc(e, n) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n), this.inc("pre", n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n), this.inc("pre", n);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let r = this.prerelease.length;
          for (; --r >= 0; )
            typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
          r === -1 && this.prerelease.push(0);
        }
        n && (this.prerelease[0] === n ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0]) : this.prerelease = [n, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.format(), this.raw = this.version, this;
  }
};
var _t = (t, e, n) => new E(t, n).compare(new E(e, n));
var k = _t;
var Dt = (t, e, n) => k(t, e, n) === 0;
var kt = Dt;
var Jt = (t, e, n) => k(t, e, n) !== 0;
var qt = Jt;
var Gt = (t, e, n) => k(t, e, n) > 0;
var Ut = Gt;
var Kt = (t, e, n) => k(t, e, n) >= 0;
var jt = Kt;
var Ft = (t, e, n) => k(t, e, n) < 0;
var Wt = Ft;
var Xt = (t, e, n) => k(t, e, n) <= 0;
var Bt = Xt;
var Ht = (t, e, n, r) => {
  switch (e) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t === n;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t !== n;
    case "":
    case "=":
    case "==":
      return kt(t, n, r);
    case "!=":
      return qt(t, n, r);
    case ">":
      return Ut(t, n, r);
    case ">=":
      return jt(t, n, r);
    case "<":
      return Wt(t, n, r);
    case "<=":
      return Bt(t, n, r);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var Ee = Ht;
var F = Symbol("SemVer ANY");
var O = class {
  static get ANY() {
    return F;
  }
  constructor(e, n) {
    if (n && typeof n == "object" || (n = { loose: !!n, includePrerelease: false }), e instanceof O) {
      if (e.loose === !!n.loose)
        return e;
      e = e.value;
    }
    d("comparator", e, n), this.options = n, this.loose = !!n.loose, this.parse(e), this.semver === F ? this.value = "" : this.value = this.operator + this.semver.version, d("comp", this);
  }
  parse(e) {
    let n = this.options.loose ? _e[De.COMPARATORLOOSE] : _e[De.COMPARATOR], r = e.match(n);
    if (!r)
      throw new TypeError(`Invalid comparator: ${e}`);
    this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new E(r[2], this.options.loose) : this.semver = F;
  }
  toString() {
    return this.value;
  }
  test(e) {
    if (d("Comparator.test", e, this.options.loose), this.semver === F || e === F)
      return true;
    if (typeof e == "string")
      try {
        e = new E(e, this.options);
      } catch (n) {
        return false;
      }
    return Ee(e, this.operator, this.semver, this.options);
  }
  intersects(e, n) {
    if (!(e instanceof O))
      throw new TypeError("a Comparator is required");
    if (n && typeof n == "object" || (n = { loose: !!n, includePrerelease: false }), this.operator === "")
      return this.value === "" || new N(e.value, n).test(this.value);
    if (e.operator === "")
      return e.value === "" || new N(this.value, n).test(e.semver);
    let r = !(this.operator !== ">=" && this.operator !== ">" || e.operator !== ">=" && e.operator !== ">"), s = !(this.operator !== "<=" && this.operator !== "<" || e.operator !== "<=" && e.operator !== "<"), o2 = this.semver.version === e.semver.version, a2 = !(this.operator !== ">=" && this.operator !== "<=" || e.operator !== ">=" && e.operator !== "<="), i = Ee(this.semver, "<", e.semver, n) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), c = Ee(this.semver, ">", e.semver, n) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
    return r || s || o2 && a2 || i || c;
  }
};
var { re: _e, t: De } = K;
var N = class {
  constructor(e, n) {
    if (n && typeof n == "object" || (n = { loose: !!n, includePrerelease: false }), e instanceof N)
      return e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease ? e : new N(e.raw, n);
    if (e instanceof O)
      return this.raw = e.value, this.set = [[e]], this.format(), this;
    if (this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((r) => this.parseRange(r.trim())).filter((r) => r.length), !this.set.length)
      throw new TypeError(`Invalid SemVer Range: ${e}`);
    this.format();
  }
  format() {
    return this.range = this.set.map((e) => e.join(" ").trim()).join("||").trim(), this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(e) {
    let { loose: n } = this.options;
    e = e.trim();
    let r = n ? g2[f.HYPHENRANGELOOSE] : g2[f.HYPHENRANGE];
    e = e.replace(r, cn(this.options.includePrerelease)), d("hyphen replace", e), e = e.replace(g2[f.COMPARATORTRIM], Vt), d("comparator trim", e, g2[f.COMPARATORTRIM]), e = (e = (e = e.replace(g2[f.TILDETRIM], zt)).replace(g2[f.CARETTRIM], Yt)).split(/\s+/).join(" ");
    let s = n ? g2[f.COMPARATORLOOSE] : g2[f.COMPARATOR];
    return e.split(" ").map((o2) => Zt(o2, this.options)).join(" ").split(/\s+/).map((o2) => an(o2, this.options)).filter(this.options.loose ? (o2) => !!o2.match(s) : () => true).map((o2) => new O(o2, this.options));
  }
  intersects(e, n) {
    if (!(e instanceof N))
      throw new TypeError("a Range is required");
    return this.set.some((r) => ke(r, n) && e.set.some((s) => ke(s, n) && r.every((o2) => s.every((a2) => o2.intersects(a2, n)))));
  }
  test(e) {
    if (!e)
      return false;
    if (typeof e == "string")
      try {
        e = new E(e, this.options);
      } catch (n) {
        return false;
      }
    for (let n = 0; n < this.set.length; n++)
      if (ln(this.set[n], e, this.options))
        return true;
    return false;
  }
};
var { re: g2, t: f, comparatorTrimReplace: Vt, tildeTrimReplace: zt, caretTrimReplace: Yt } = K;
var ke = (t, e) => {
  let n = true, r = t.slice(), s = r.pop();
  for (; n && r.length; )
    n = r.every((o2) => s.intersects(o2, e)), s = r.pop();
  return n;
};
var Zt = (t, e) => (d("comp", t, e), t = tn(t, e), d("caret", t), t = Qt(t, e), d("tildes", t), t = rn(t, e), d("xrange", t), t = on(t, e), d("stars", t), t);
var R = (t) => !t || t.toLowerCase() === "x" || t === "*";
var Qt = (t, e) => t.trim().split(/\s+/).map((n) => en(n, e)).join(" ");
var en = (t, e) => {
  let n = e.loose ? g2[f.TILDELOOSE] : g2[f.TILDE];
  return t.replace(n, (r, s, o2, a2, i) => {
    let c;
    return d("tilde", t, r, s, o2, a2, i), R(s) ? c = "" : R(o2) ? c = `>=${s}.0.0 <${+s + 1}.0.0-0` : R(a2) ? c = `>=${s}.${o2}.0 <${s}.${+o2 + 1}.0-0` : i ? (d("replaceTilde pr", i), c = `>=${s}.${o2}.${a2}-${i} <${s}.${+o2 + 1}.0-0`) : c = `>=${s}.${o2}.${a2} <${s}.${+o2 + 1}.0-0`, d("tilde return", c), c;
  });
};
var tn = (t, e) => t.trim().split(/\s+/).map((n) => nn(n, e)).join(" ");
var nn = (t, e) => {
  d("caret", t, e);
  let n = e.loose ? g2[f.CARETLOOSE] : g2[f.CARET], r = e.includePrerelease ? "-0" : "";
  return t.replace(n, (s, o2, a2, i, c) => {
    let p2;
    return d("caret", t, s, o2, a2, i, c), R(o2) ? p2 = "" : R(a2) ? p2 = `>=${o2}.0.0${r} <${+o2 + 1}.0.0-0` : R(i) ? p2 = o2 === "0" ? `>=${o2}.${a2}.0${r} <${o2}.${+a2 + 1}.0-0` : `>=${o2}.${a2}.0${r} <${+o2 + 1}.0.0-0` : c ? (d("replaceCaret pr", c), p2 = o2 === "0" ? a2 === "0" ? `>=${o2}.${a2}.${i}-${c} <${o2}.${a2}.${+i + 1}-0` : `>=${o2}.${a2}.${i}-${c} <${o2}.${+a2 + 1}.0-0` : `>=${o2}.${a2}.${i}-${c} <${+o2 + 1}.0.0-0`) : (d("no pr"), p2 = o2 === "0" ? a2 === "0" ? `>=${o2}.${a2}.${i}${r} <${o2}.${a2}.${+i + 1}-0` : `>=${o2}.${a2}.${i}${r} <${o2}.${+a2 + 1}.0-0` : `>=${o2}.${a2}.${i} <${+o2 + 1}.0.0-0`), d("caret return", p2), p2;
  });
};
var rn = (t, e) => (d("replaceXRanges", t, e), t.split(/\s+/).map((n) => sn(n, e)).join(" "));
var sn = (t, e) => {
  t = t.trim();
  let n = e.loose ? g2[f.XRANGELOOSE] : g2[f.XRANGE];
  return t.replace(n, (r, s, o2, a2, i, c) => {
    d("xRange", t, r, s, o2, a2, i, c);
    let p2 = R(o2), l2 = p2 || R(a2), u2 = l2 || R(i), v = u2;
    return s === "=" && v && (s = ""), c = e.includePrerelease ? "-0" : "", p2 ? r = s === ">" || s === "<" ? "<0.0.0-0" : "*" : s && v ? (l2 && (a2 = 0), i = 0, s === ">" ? (s = ">=", l2 ? (o2 = +o2 + 1, a2 = 0, i = 0) : (a2 = +a2 + 1, i = 0)) : s === "<=" && (s = "<", l2 ? o2 = +o2 + 1 : a2 = +a2 + 1), s === "<" && (c = "-0"), r = `${s + o2}.${a2}.${i}${c}`) : l2 ? r = `>=${o2}.0.0${c} <${+o2 + 1}.0.0-0` : u2 && (r = `>=${o2}.${a2}.0${c} <${o2}.${+a2 + 1}.0-0`), d("xRange return", r), r;
  });
};
var on = (t, e) => (d("replaceStars", t, e), t.trim().replace(g2[f.STAR], ""));
var an = (t, e) => (d("replaceGTE0", t, e), t.trim().replace(g2[e.includePrerelease ? f.GTE0PRE : f.GTE0], ""));
var cn = (t) => (e, n, r, s, o2, a2, i, c, p2, l2, u2, v, M) => `${n = R(r) ? "" : R(s) ? `>=${r}.0.0${t ? "-0" : ""}` : R(o2) ? `>=${r}.${s}.0${t ? "-0" : ""}` : a2 ? `>=${n}` : `>=${n}${t ? "-0" : ""}`} ${c = R(p2) ? "" : R(l2) ? `<${+p2 + 1}.0.0-0` : R(u2) ? `<${p2}.${+l2 + 1}.0-0` : v ? `<=${p2}.${l2}.${u2}-${v}` : t ? `<${p2}.${l2}.${+u2 + 1}-0` : `<=${c}`}`.trim();
var ln = (t, e, n) => {
  for (let r = 0; r < t.length; r++)
    if (!t[r].test(e))
      return false;
  if (e.prerelease.length && !n.includePrerelease) {
    for (let r = 0; r < t.length; r++)
      if (d(t[r].semver), t[r].semver !== O.ANY && t[r].semver.prerelease.length > 0) {
        let s = t[r].semver;
        if (s.major === e.major && s.minor === e.minor && s.patch === e.patch)
          return true;
      }
    return false;
  }
  return true;
};
var Je = (t, e, n) => {
  try {
    e = new N(e, n);
  } catch (r) {
    return false;
  }
  return e.test(t);
};
var { MAX_LENGTH: pn } = me;
var { re: qe, t: Ge } = K;
var un = (t, e) => {
  if (e && typeof e == "object" || (e = { loose: !!e, includePrerelease: false }), t instanceof E)
    return t;
  if (typeof t != "string" || t.length > pn || !(e.loose ? qe[Ge.LOOSE] : qe[Ge.FULL]).test(t))
    return null;
  try {
    return new E(t, e);
  } catch (n) {
    return null;
  }
};
var dn = un;
var { re: Z, t: Q } = K;
var Ue = (t, e) => {
  if (t instanceof E)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  let n = null;
  if ((e = e || {}).rtl) {
    let r;
    for (; (r = Z[Q.COERCERTL].exec(t)) && (!n || n.index + n[0].length !== t.length); )
      n && r.index + r[0].length === n.index + n[0].length || (n = r), Z[Q.COERCERTL].lastIndex = r.index + r[1].length + r[2].length;
    Z[Q.COERCERTL].lastIndex = -1;
  } else
    n = t.match(Z[Q.COERCE]);
  return n === null ? null : dn(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, e);
};
function mn(t) {
  return String.fromCharCode(parseInt(t.slice(1), 16));
}
function En(t) {
  return `%${`00${t.charCodeAt(0).toString(16)}`.slice(-2)}`;
}
function hn(t) {
  return btoa(encodeURIComponent(t).replace(/%[0-9A-F]{2}/g, mn));
}
function fn(t) {
  return decodeURIComponent(Array.from(atob(t), En).join(""));
}
function ee(t) {
  return hn(JSON.stringify(t));
}
function Ke(t) {
  return JSON.parse(fn(t));
}
function $(t) {
  return typeof t == "undefined";
}
function Rn(t) {
  return t === null;
}
function te(t) {
  return Rn(t) || $(t);
}
function je(t) {
  return te(t) ? false : !$(t.jsonrpc) && !$(t.id) && (!$(t.result) || !$(t.error));
}
function Fe(t) {
  return te(t) ? false : typeof t == "number" && Object.values(p).includes(t);
}
function ne(t) {
  if (!t)
    return true;
  for (let e in t)
    if (Object.hasOwnProperty.call(t, e))
      return false;
  return true;
}
var m2 = {};
function Tn(t, e) {
  return Object.assign(m2, e), t;
}
var We = { "magic-sdk": "magic-sdk", "@magic-sdk/react-native": "magic-sdk-rn" };
var b = class extends Error {
  constructor(e, n) {
    super(`Magic SDK Error: [${e}] ${n}`);
    this.code = e;
    this.rawMessage = n;
    this.__proto__ = Error;
    Object.setPrototypeOf(this, b.prototype);
  }
};
var w = class extends Error {
  constructor(e) {
    super();
    this.__proto__ = Error;
    let n = Number(e == null ? void 0 : e.code);
    this.rawMessage = (e == null ? void 0 : e.message) || "Internal error", this.code = Fe(n) ? n : p.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, Object.setPrototypeOf(this, w.prototype);
  }
};
var W = class {
  constructor(e, n) {
    this.code = e;
    this.rawMessage = n;
    this.message = `Magic SDK Warning: [${e}] ${n}`;
  }
  log() {
    console.warn(this.message);
  }
};
var X = class extends Error {
  constructor(e, n, r, s) {
    super(`Magic Extension Error (${e.name}): [${n}] ${r}`);
    this.code = n;
    this.rawMessage = r;
    this.data = s;
    this.__proto__ = Error;
    Object.setPrototypeOf(this, X.prototype);
  }
};
var se = class {
  constructor(e, n, r) {
    this.code = n;
    this.rawMessage = r;
    this.message = `Magic Extension Warning (${e.name}): [${n}] ${r}`;
  }
  log() {
    console.warn(this.message);
  }
};
function Xe() {
  return new b(a.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
}
function cr() {
  return new b(a.ModalNotReady, "Modal is not ready.");
}
function Be() {
  return new b(a.MalformedResponse, "Response from the Magic iframe is malformed.");
}
function He(t) {
  return new b(a.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${t}\` can be accessed. Do not invoke \`Extension.${t}\` inside an extension constructor.`);
}
function Ve(t) {
  let e = `Some extensions are incompatible with \`${m2.sdkName}@${m2.version}\`:`;
  return t.filter((n) => typeof n.compat != "undefined" && n.compat !== null).forEach((n) => {
    let r = n.compat[m2.sdkName];
    typeof r == "string" ? e += `
  - Extension \`${n.name}\` supports version(s) \`${r}\`` : r || (e += `
  - Extension \`${n.name}\` does not support ${m2.platform} environments.`);
  }), new b(a.IncompatibleExtensions, e);
}
function ze(t) {
  let e = (n) => {
    let r = n + 1, s = r % 10, o2 = r % 100;
    return s === 1 && o2 !== 11 ? `${r}st` : s === 2 && o2 !== 12 ? `${r}nd` : s === 3 && o2 !== 13 ? `${r}rd` : `${r}th`;
  };
  return new b(a.InvalidArgument, `Invalid ${e(t.argument)} argument given to \`${t.procedure}\`.
  Expected: \`${t.expected}\`
  Received: \`${t.received}\``);
}
function lr() {
  return new W(m.DuplicateIframe, "Duplicate iframes found.");
}
function Ye() {
  return new W(m.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
}
function Ze() {
  return new W(m.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${m2.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);
}
function* xn() {
  let t = 0;
  for (; ; )
    t < Number.MAX_SAFE_INTEGER ? yield ++t : t = 0;
}
var In = xn();
function he() {
  return In.next().value;
}
var Qe = Symbol("Payload pre-processed by Magic SDK");
function et(t) {
  return Object.defineProperty(t, Qe, { value: true, enumerable: false }), t;
}
function Pn(t) {
  return !!t[Qe];
}
function C(t) {
  var e, n, r;
  return Pn(t) || (t.jsonrpc = (e = t.jsonrpc) != null ? e : "2.0", t.id = he(), t.method = (n = t.method) != null ? n : "noop", t.params = (r = t.params) != null ? r : [], et(t)), t;
}
function h(t, e = []) {
  return et({ params: e, method: t, jsonrpc: "2.0", id: he() });
}
var _ = class {
  constructor(e) {
    e instanceof _ ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : je(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);
  }
  applyError(e) {
    return this._error = e, this;
  }
  applyResult(e) {
    return this._result = e, this;
  }
  get hasError() {
    return typeof this._error != "undefined" && this._error !== null;
  }
  get hasResult() {
    return typeof this._result != "undefined";
  }
  get payload() {
    return { jsonrpc: this._jsonrpc, id: this._id, result: this._result, error: this._error };
  }
};
var rt = wt(nt());
var st = class extends rt.default {
};
function ie() {
  let t = new st();
  return { emitter: t, createChainingEmitterMethod: (r, s) => (...o2) => (t[r].apply(t, o2), s), createBoundEmitterMethod: (r) => (...s) => t[r].apply(t, s) };
}
var ot = Symbol("isPromiEvent");
function it(t) {
  return !!t[ot];
}
function ae(t) {
  let e = ge(t), { createBoundEmitterMethod: n, createChainingEmitterMethod: r } = ie(), s = Symbol("Promise.then"), o2 = Symbol("Promise.catch"), a2 = Symbol("Promise.finally"), i = (l2, u2) => (...v) => {
    let M = u2[l2].apply(u2, v);
    return c(M);
  }, c = (l2) => Object.assign(l2, { [ot]: true, [s]: l2[s] || l2.then, [o2]: l2[o2] || l2.catch, [a2]: l2[a2] || l2.finally, then: i(s, l2), catch: i(o2, l2), finally: i(a2, l2), on: r("on", l2), once: r("once", l2), addListener: r("addListener", l2), off: r("off", l2), removeListener: r("removeListener", l2), removeAllListeners: r("removeAllListeners", l2), emit: n("emit"), eventNames: n("eventNames"), listeners: n("listeners"), listenerCount: n("listenerCount") }), p2 = c(e.then((l2) => (p2.emit("done", l2), p2.emit("settled"), l2), (l2) => {
    throw p2.emit("error", l2), p2.emit("settled"), l2;
  }));
  return p2;
}
function ge(t) {
  return new Promise((e, n) => {
    let r = t(e, n);
    Promise.resolve(r).catch(n);
  });
}
var P = class {
  constructor(e) {
    this.sdk = e;
  }
  get overlay() {
    return this.sdk.overlay;
  }
  request(e) {
    let n = this.overlay.post(g.MAGIC_HANDLE_REQUEST, C(e)), r = ae((o2, a2) => {
      n.then((i) => {
        if (s(), i.hasError)
          a2(new w(i.payload.error));
        else if (i.hasResult)
          o2(i.payload.result);
        else
          throw Be();
      }).catch((i) => {
        s(), a2(i);
      });
    }), s = this.overlay.on(u.MAGIC_HANDLE_EVENT, (o2) => {
      var i;
      let { response: a2 } = o2.data;
      if (a2.id === e.id && ((i = a2.result) == null ? void 0 : i.event)) {
        let { event: c, params: p2 = [] } = a2.result;
        r.emit(c, ...p2);
      }
    });
    return r;
  }
};
var ye = class extends P {
  loginWithMagicLink(e) {
    let { email: n, showUI: r = true, redirectURI: s } = e, o2 = h(this.sdk.testMode ? o.LoginWithMagicLinkTestMode : o.LoginWithMagicLink, [{ email: n, showUI: r, redirectURI: s }]);
    return this.request(o2);
  }
  loginWithSMS(e) {
    let { phoneNumber: n } = e, r = h(this.sdk.testMode ? o.LoginWithSmsTestMode : o.LoginWithSms, [{ phoneNumber: n, showUI: true }]);
    return this.request(r);
  }
  loginWithEmailOTP(e) {
    let { email: n } = e, r = h(this.sdk.testMode ? o.LoginWithEmailOTPTestMode : o.LoginWithEmailOTP, [{ email: n, showUI: true }]);
    return this.request(r);
  }
  loginWithCredential(e) {
    let n = e != null ? e : "";
    if (!e && m2.platform === "web") {
      n = window.location.search;
      let s = window.location.origin + window.location.pathname;
      window.history.replaceState(null, "", s);
    }
    let r = h(this.sdk.testMode ? o.LoginWithCredentialTestMode : o.LoginWithCredential, [n]);
    return this.request(r);
  }
};
var H = {};
Mt(H, { clear: () => wn, getItem: () => D, iterate: () => On, key: () => Ln, keys: () => Sn, length: () => An, removeItem: () => le, setItem: () => q });
var ce;
function L(t) {
  return (...e) => I(this, null, function* () {
    return ce || (ce = yield m2.configureStorage()), yield ce.ready(), ce[t](...e);
  });
}
var D = L("getItem");
var q = L("setItem");
var le = L("removeItem");
var wn = L("clear");
var An = L("length");
var Ln = L("key");
var Sn = L("keys");
var On = L("iterate");
function at() {
  let t = window.crypto.getRandomValues(new Uint8Array(16));
  t[6] = t[6] & 15 | 64, t[8] = t[8] & 191 | 128;
  let e = "";
  return e += t[0].toString(16), e += t[1].toString(16), e += t[2].toString(16), e += t[3].toString(16), e += "-", e += t[4].toString(16), e += t[5].toString(16), e += "-", e += t[6].toString(16), e += t[7].toString(16), e += "-", e += t[8].toString(16), e += t[9].toString(16), e += "-", e += t[10].toString(16), e += t[11].toString(16), e += t[12].toString(16), e += t[13].toString(16), e += t[14].toString(16), e += t[15].toString(16), e;
}
var Re = "STORE_KEY_PRIVATE_KEY";
var pe = "STORE_KEY_PUBLIC_JWK";
var Te = "ECDSA";
var ct = "P-256";
var Cn = { name: Te, namedCurve: ct };
var _n = { name: Te, namedCurve: ct };
function lt() {
  le(pe), le(Re);
}
function pt() {
  return I(this, null, function* () {
    let t = yield Dn();
    if (!t) {
      console.info("unable to create public key or webcrypto is unsupported");
      return;
    }
    let { subtle: e } = window.crypto, n = yield D(Re);
    if (!n || !e) {
      console.info("unable to find private key or webcrypto unsupported");
      return;
    }
    let r = { iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), jti: at() }, s = { typ: "dpop+jwt", alg: "ES256", jwk: t }, o2 = { protected: ut(JSON.stringify(s)), claims: ut(JSON.stringify(r)) }, a2 = qn(`${o2.protected}.${o2.claims}`), i = { name: Te, hash: { name: "SHA-256" } }, c = Un(new Uint8Array(yield e.sign(i, n, a2)));
    return `${o2.protected}.${o2.claims}.${c}`;
  });
}
function Dn() {
  return I(this, null, function* () {
    if (!Jn()) {
      console.info("webcrypto is not supported");
      return;
    }
    return (yield D(pe)) || (yield kn()), D(pe);
  });
}
function kn() {
  return I(this, null, function* () {
    let t = null, { subtle: e } = window.crypto, n = yield e.generateKey(Cn, true, ["sign"]), r = yield e.exportKey("jwk", n.privateKey);
    t = yield e.exportKey("jwk", n.publicKey);
    let s = yield e.importKey("jwk", r, _n, false, ["sign"]);
    yield q(Re, s), yield q(pe, t);
  });
}
function Jn() {
  let t = typeof window != "undefined" && !!window.crypto, e = t && !!window.crypto.subtle;
  return t && e;
}
function ut(t) {
  return dt(Gn(t));
}
function qn(t) {
  return new TextEncoder().encode(t);
}
function dt(t) {
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "");
}
function Gn(t) {
  return encodeURIComponent(t).replace(/%([0-9A-F]{2})/g, (n, r) => String.fromCharCode(parseInt(r, 16)));
}
function Un(t) {
  let e = "";
  return t.forEach((n) => {
    e += String.fromCharCode(n);
  }), dt(e);
}
var ve = class extends P {
  getIdToken(e) {
    let n = h(this.sdk.testMode ? o.GetIdTokenTestMode : o.GetIdToken, [e]);
    return this.request(n);
  }
  generateIdToken(e) {
    let n = h(this.sdk.testMode ? o.GenerateIdTokenTestMode : o.GenerateIdToken, [e]);
    return this.request(n);
  }
  getMetadata() {
    let e = h(this.sdk.testMode ? o.GetMetadataTestMode : o.GetMetadata);
    return this.request(e);
  }
  updateEmail(e) {
    let { email: n, showUI: r = true } = e, s = h(this.sdk.testMode ? o.UpdateEmailTestMode : o.UpdateEmail, [{ email: n, showUI: r }]);
    return this.request(s);
  }
  isLoggedIn() {
    let e = h(this.sdk.testMode ? o.IsLoggedInTestMode : o.IsLoggedIn);
    return this.request(e);
  }
  logout() {
    lt();
    let e = h(this.sdk.testMode ? o.LogoutTestMode : o.Logout);
    return this.request(e);
  }
  showSettings() {
    let e = h(this.sdk.testMode ? o.UserSettingsTestMode : o.UserSettings);
    return this.request(e);
  }
};
var { createBoundEmitterMethod: ue, createChainingEmitterMethod: G } = ie();
var xe = class extends P {
  constructor() {
    super(...arguments);
    this.isMagic = true;
    this.on = G("on", this);
    this.once = G("once", this);
    this.addListener = G("addListener", this);
    this.off = G("off", this);
    this.removeListener = G("removeListener", this);
    this.removeAllListeners = G("removeAllListeners", this);
    this.emit = ue("emit");
    this.eventNames = ue("eventNames");
    this.listeners = ue("listeners");
    this.listenerCount = ue("listenerCount");
  }
  sendAsync(e, n) {
    if (!n)
      throw ze({ procedure: "Magic.rpcProvider.sendAsync", argument: 1, expected: "function", received: n === null ? "null" : typeof n });
    if (Array.isArray(e))
      this.overlay.post(g.MAGIC_HANDLE_REQUEST, e.map((r) => {
        let s = C(r);
        return this.prefixPayloadMethodForTestMode(s), s;
      })).then((r) => {
        n(null, r.map((s) => we(z({}, s.payload), { error: s.hasError ? new w(s.payload.error) : null })));
      });
    else {
      let r = C(e);
      this.prefixPayloadMethodForTestMode(r), this.overlay.post(g.MAGIC_HANDLE_REQUEST, r).then((s) => {
        n(s.hasError ? new w(s.payload.error) : null, s.payload);
      });
    }
  }
  send(e, n) {
    if (typeof e == "string") {
      let s = h(e, Array.isArray(n) ? n : []);
      return this.request(s);
    }
    if (Array.isArray(e) || !!n) {
      this.sendAsync(e, n);
      return;
    }
    let r = Ye();
    return r.log(), new _(e).applyError({ code: -32603, message: r.rawMessage }).payload;
  }
  enable() {
    let e = h("eth_accounts");
    return this.request(e);
  }
  request(e) {
    return this.prefixPayloadMethodForTestMode(e), super.request(e);
  }
  prefixPayloadMethodForTestMode(e) {
    let n = "testMode/eth/";
    this.sdk.testMode && (e.method = `${n}${e.method}`);
  }
};
function Ie(t, e) {
  return e ? new URL(t, e) : new URL(t);
}
var Et = ["request", "overlay", "sdk"];
function Kn(t) {
  let e = Object.getPrototypeOf(t), n = [e];
  for (; e !== P.prototype; )
    e = Object.getPrototypeOf(e), n.push(e);
  return n;
}
var Pe = class extends P {
  constructor() {
    super(void 0);
    this.__sdk_access_field_descriptors__ = /* @__PURE__ */ new Map();
    this.__is_initialized__ = false;
    this.utils = { createPromiEvent: ae, isPromiEvent: it, encodeJSON: ee, decodeJSON: Ke, createJsonRpcRequestPayload: h, standardizeJsonRpcRequestPayload: C, storage: H };
    let e = [this, ...Kn(this)];
    Et.forEach((n) => {
      let r = e.map((i) => Object.getOwnPropertyDescriptor(i, n)), s = r.findIndex((i) => !!i), o2 = s > 0, a2 = r[s];
      a2 && (this.__sdk_access_field_descriptors__.set(n, { descriptor: a2, isPrototypeField: o2 }), Object.defineProperty(this, n, { configurable: true, get: () => {
        throw He(n);
      } }));
    });
  }
  init(e) {
    this.__is_initialized__ || (Et.forEach((n) => {
      if (this.__sdk_access_field_descriptors__.has(n)) {
        let { descriptor: r, isPrototypeField: s } = this.__sdk_access_field_descriptors__.get(n);
        s ? delete this[n] : Object.defineProperty(this, n, r);
      }
    }), this.sdk = e, this.__is_initialized__ = true);
  }
  createDeprecationWarning(e) {
    let { method: n, removalVersion: r, useInstead: s } = e, o2 = s ? ` Use \`${s}\` instead.` : "", a2 = `\`${n}\` will be removed from this Extension in version \`${r}\`.${o2}`;
    return new se(this, "DEPRECATION_NOTICE", a2);
  }
  createWarning(e, n) {
    return new se(this, e, n);
  }
  createError(e, n, r) {
    return new X(this, e, n, r);
  }
};
var ht = class extends Pe {
};
var S = class extends Pe {
};
S.Internal = ht, S.Anonymous = "anonymous extension";
function ft(t) {
  return t.compat && t.compat[m2.sdkName] != null ? typeof t.compat[m2.sdkName] == "string" ? Je(Ue(m2.version), t.compat[m2.sdkName]) : !!t.compat[m2.sdkName] : true;
}
function jn(t) {
  var s;
  let e = (s = t == null ? void 0 : t.extensions) != null ? s : [], n = {}, r = [];
  if (Array.isArray(e) ? e.forEach((o2) => {
    ft(o2) ? (o2.init(this), (o2.name || o2.name !== S.Anonymous) && (this[o2.name] = o2), o2 instanceof S.Internal && (ne(o2.config) || (n[o2.name] = o2.config))) : r.push(o2);
  }) : Object.keys(e).forEach((o2) => {
    if (ft(e[o2])) {
      e[o2].init(this);
      let a2 = e[o2];
      this[o2] = a2, a2 instanceof S.Internal && (ne(a2.config) || (n[e[o2].name] = a2.config));
    } else
      r.push(e[o2]);
  }), r.length)
    throw Ve(r);
  return n;
}
var V = class {
  constructor(e, n) {
    this.apiKey = e;
    var a2;
    if (!e)
      throw Xe();
    m2.platform === "react-native" && (n == null ? void 0 : n.endpoint) && Ze().log();
    let { defaultEndpoint: r, version: s } = m2;
    this.testMode = !!(n == null ? void 0 : n.testMode), this.endpoint = Ie((a2 = n == null ? void 0 : n.endpoint) != null ? a2 : r).origin, this.auth = new ye(this), this.user = new ve(this), this.rpcProvider = new xe(this);
    let o2 = jn.call(this, n);
    this.parameters = ee(z({ API_KEY: this.apiKey, DOMAIN_ORIGIN: window.location ? window.location.origin : "", ETH_NETWORK: n == null ? void 0 : n.network, host: Ie(this.endpoint).host, sdk: We[m2.sdkName], version: s, ext: ne(o2) ? void 0 : o2, locale: (n == null ? void 0 : n.locale) || "en_US" }, m2.bundleId ? { bundleId: m2.bundleId } : {}));
  }
  get overlay() {
    if (!V.__overlays__.has(this.parameters)) {
      let e = new m2.ViewController(this.endpoint, this.parameters);
      e.init(), V.__overlays__.set(this.parameters, e);
    }
    return V.__overlays__.get(this.parameters);
  }
  preload() {
    return I(this, null, function* () {
      yield this.overlay.ready;
    });
  }
};
var $e = V;
$e.__overlays__ = /* @__PURE__ */ new Map();
function Fn(t, e) {
  return e && Array.isArray(t) ? t.find((n) => n.id === e) : t;
}
function Wn(t, e) {
  var s;
  let n = (s = e.data.response) == null ? void 0 : s.id, r = Fn(t, n);
  if (n && r) {
    let o2 = new _(r).applyResult(e.data.response.result).applyError(e.data.response.error);
    return { id: n, response: o2 };
  }
  return {};
}
function Xn(t, e) {
  return I(this, null, function* () {
    let n = yield D("rt"), r;
    if (m2.platform === "web")
      try {
        r = yield pt();
      } catch (s) {
        console.error("webcrypto error", s);
      }
    return r ? n ? { msgType: t, payload: e, jwt: r, rt: n } : { msgType: t, payload: e, jwt: r } : { msgType: t, payload: e };
  });
}
function Bn(t) {
  return I(this, null, function* () {
    !t.data.rt || (yield q("rt", t.data.rt));
  });
}
var gt = class {
  constructor(e, n) {
    this.endpoint = e;
    this.parameters = n;
    this.messageHandlers = /* @__PURE__ */ new Set();
    this.ready = this.waitForReady(), this.listen();
  }
  post(e, n) {
    return I(this, null, function* () {
      return ge((r) => I(this, null, function* () {
        yield this.ready;
        let s = [], o2 = Array.isArray(n) ? n.map((p2) => p2.id) : [], a2 = yield Xn(`${e}-${this.parameters}`, n);
        yield this._post(a2);
        let i = (p2) => (l2) => {
          let { id: u2, response: v } = Wn(n, l2);
          Bn(l2), u2 && v && Array.isArray(n) && o2.includes(u2) ? (s.push(v), s.length === n.length && (p2(), r(s))) : u2 && v && !Array.isArray(n) && u2 === n.id && (p2(), r(v));
        }, c = this.on(u.MAGIC_HANDLE_RESPONSE, i(() => c()));
      }));
    });
  }
  on(e, n) {
    let r = n.bind(window), s = (o2) => {
      o2.data.msgType === `${e}-${this.parameters}` && r(o2);
    };
    return this.messageHandlers.add(s), () => this.messageHandlers.delete(s);
  }
  waitForReady() {
    return new Promise((e) => {
      this.on(u.MAGIC_OVERLAY_READY, () => e());
    });
  }
  listen() {
    this.on(u.MAGIC_HIDE_OVERLAY, () => {
      this.hideOverlay();
    }), this.on(u.MAGIC_SHOW_OVERLAY, () => {
      this.showOverlay();
    });
  }
};

// node_modules/@web3-onboard/magic/node_modules/@magic-sdk/commons/dist/es/index.mjs
var import_dist3 = __toESM(require_dist(), 1);

// node_modules/@web3-onboard/magic/node_modules/magic-sdk/dist/es/index.mjs
var Zr = Object.create;
var De2 = Object.defineProperty;
var qr = Object.getOwnPropertyDescriptor;
var kr = Object.getOwnPropertyNames;
var et2 = Object.getPrototypeOf;
var rt2 = Object.prototype.hasOwnProperty;
var tt = (p2) => De2(p2, "__esModule", { value: true });
var ve2 = ((p2) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(p2, { get: (g3, O2) => (typeof __require != "undefined" ? __require : g3)[O2] }) : p2)(function(p2) {
  if (typeof __require != "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + p2 + '" is not supported');
});
var $e2 = (p2, g3) => () => (g3 || p2((g3 = { exports: {} }).exports, g3), g3.exports);
var nt2 = (p2, g3, O2, L2) => {
  if (g3 && typeof g3 == "object" || typeof g3 == "function")
    for (let M of kr(g3))
      !rt2.call(p2, M) && (O2 || M !== "default") && De2(p2, M, { get: () => g3[M], enumerable: !(L2 = qr(g3, M)) || L2.enumerable });
  return p2;
};
var Ze2 = (p2, g3) => nt2(tt(De2(p2 != null ? Zr(et2(p2)) : {}, "default", !g3 && p2 && p2.__esModule ? { get: () => p2.default, enumerable: true } : { value: p2, enumerable: true })), p2);
var se2 = (p2, g3, O2) => new Promise((L2, M) => {
  var Q2 = (S2) => {
    try {
      Y2(O2.next(S2));
    } catch (P2) {
      M(P2);
    }
  }, C2 = (S2) => {
    try {
      Y2(O2.throw(S2));
    } catch (P2) {
      M(P2);
    }
  }, Y2 = (S2) => S2.done ? L2(S2.value) : Promise.resolve(S2.value).then(Q2, C2);
  Y2((O2 = O2.apply(p2, g3)).next());
});
var ke2 = $e2((qe2, Ne2) => {
  (function(p2) {
    if (typeof qe2 == "object" && typeof Ne2 != "undefined")
      Ne2.exports = p2();
    else if (typeof define == "function" && define.amd)
      define([], p2);
    else {
      var g3;
      typeof window != "undefined" ? g3 = window : typeof global != "undefined" ? g3 = global : typeof self != "undefined" ? g3 = self : g3 = this, g3.localforage = p2();
    }
  })(function() {
    var p2, g3, O2;
    return function L2(M, Q2, C2) {
      function Y2(K2, Z2) {
        if (!Q2[K2]) {
          if (!M[K2]) {
            var m3 = typeof ve2 == "function" && ve2;
            if (!Z2 && m3)
              return m3(K2, true);
            if (S2)
              return S2(K2, true);
            var w2 = new Error("Cannot find module '" + K2 + "'");
            throw w2.code = "MODULE_NOT_FOUND", w2;
          }
          var N2 = Q2[K2] = { exports: {} };
          M[K2][0].call(N2.exports, function(z2) {
            var q2 = M[K2][1][z2];
            return Y2(q2 || z2);
          }, N2, N2.exports, L2, M, Q2, C2);
        }
        return Q2[K2].exports;
      }
      for (var S2 = typeof ve2 == "function" && ve2, P2 = 0; P2 < C2.length; P2++)
        Y2(C2[P2]);
      return Y2;
    }({ 1: [function(L2, M, Q2) {
      (function(C2) {
        "use strict";
        var Y2 = C2.MutationObserver || C2.WebKitMutationObserver, S2;
        if (Y2) {
          var P2 = 0, K2 = new Y2(z2), Z2 = C2.document.createTextNode("");
          K2.observe(Z2, { characterData: true }), S2 = function() {
            Z2.data = P2 = ++P2 % 2;
          };
        } else if (!C2.setImmediate && typeof C2.MessageChannel != "undefined") {
          var m3 = new C2.MessageChannel();
          m3.port1.onmessage = z2, S2 = function() {
            m3.port2.postMessage(0);
          };
        } else
          "document" in C2 && "onreadystatechange" in C2.document.createElement("script") ? S2 = function() {
            var F2 = C2.document.createElement("script");
            F2.onreadystatechange = function() {
              z2(), F2.onreadystatechange = null, F2.parentNode.removeChild(F2), F2 = null;
            }, C2.document.documentElement.appendChild(F2);
          } : S2 = function() {
            setTimeout(z2, 0);
          };
        var w2, N2 = [];
        function z2() {
          w2 = true;
          for (var F2, k2, U2 = N2.length; U2; ) {
            for (k2 = N2, N2 = [], F2 = -1; ++F2 < U2; )
              k2[F2]();
            U2 = N2.length;
          }
          w2 = false;
        }
        M.exports = q2;
        function q2(F2) {
          N2.push(F2) === 1 && !w2 && S2();
        }
      }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 2: [function(L2, M, Q2) {
      "use strict";
      var C2 = L2(1);
      function Y2() {
      }
      var S2 = {}, P2 = ["REJECTED"], K2 = ["FULFILLED"], Z2 = ["PENDING"];
      M.exports = m3;
      function m3(h2) {
        if (typeof h2 != "function")
          throw new TypeError("resolver must be a function");
        this.state = Z2, this.queue = [], this.outcome = void 0, h2 !== Y2 && q2(this, h2);
      }
      m3.prototype.catch = function(h2) {
        return this.then(null, h2);
      }, m3.prototype.then = function(h2, R2) {
        if (typeof h2 != "function" && this.state === K2 || typeof R2 != "function" && this.state === P2)
          return this;
        var I2 = new this.constructor(Y2);
        if (this.state !== Z2) {
          var B = this.state === K2 ? h2 : R2;
          N2(I2, B, this.outcome);
        } else
          this.queue.push(new w2(I2, h2, R2));
        return I2;
      };
      function w2(h2, R2, I2) {
        this.promise = h2, typeof R2 == "function" && (this.onFulfilled = R2, this.callFulfilled = this.otherCallFulfilled), typeof I2 == "function" && (this.onRejected = I2, this.callRejected = this.otherCallRejected);
      }
      w2.prototype.callFulfilled = function(h2) {
        S2.resolve(this.promise, h2);
      }, w2.prototype.otherCallFulfilled = function(h2) {
        N2(this.promise, this.onFulfilled, h2);
      }, w2.prototype.callRejected = function(h2) {
        S2.reject(this.promise, h2);
      }, w2.prototype.otherCallRejected = function(h2) {
        N2(this.promise, this.onRejected, h2);
      };
      function N2(h2, R2, I2) {
        C2(function() {
          var B;
          try {
            B = R2(I2);
          } catch (H2) {
            return S2.reject(h2, H2);
          }
          B === h2 ? S2.reject(h2, new TypeError("Cannot resolve promise with itself")) : S2.resolve(h2, B);
        });
      }
      S2.resolve = function(h2, R2) {
        var I2 = F2(z2, R2);
        if (I2.status === "error")
          return S2.reject(h2, I2.value);
        var B = I2.value;
        if (B)
          q2(h2, B);
        else {
          h2.state = K2, h2.outcome = R2;
          for (var H2 = -1, j2 = h2.queue.length; ++H2 < j2; )
            h2.queue[H2].callFulfilled(R2);
        }
        return h2;
      }, S2.reject = function(h2, R2) {
        h2.state = P2, h2.outcome = R2;
        for (var I2 = -1, B = h2.queue.length; ++I2 < B; )
          h2.queue[I2].callRejected(R2);
        return h2;
      };
      function z2(h2) {
        var R2 = h2 && h2.then;
        if (h2 && (typeof h2 == "object" || typeof h2 == "function") && typeof R2 == "function")
          return function() {
            R2.apply(h2, arguments);
          };
      }
      function q2(h2, R2) {
        var I2 = false;
        function B($2) {
          I2 || (I2 = true, S2.reject(h2, $2));
        }
        function H2($2) {
          I2 || (I2 = true, S2.resolve(h2, $2));
        }
        function j2() {
          R2(H2, B);
        }
        var J = F2(j2);
        J.status === "error" && B(J.value);
      }
      function F2(h2, R2) {
        var I2 = {};
        try {
          I2.value = h2(R2), I2.status = "success";
        } catch (B) {
          I2.status = "error", I2.value = B;
        }
        return I2;
      }
      m3.resolve = k2;
      function k2(h2) {
        return h2 instanceof this ? h2 : S2.resolve(new this(Y2), h2);
      }
      m3.reject = U2;
      function U2(h2) {
        var R2 = new this(Y2);
        return S2.reject(R2, h2);
      }
      m3.all = ae2;
      function ae2(h2) {
        var R2 = this;
        if (Object.prototype.toString.call(h2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var I2 = h2.length, B = false;
        if (!I2)
          return this.resolve([]);
        for (var H2 = new Array(I2), j2 = 0, J = -1, $2 = new this(Y2); ++J < I2; )
          ee2(h2[J], J);
        return $2;
        function ee2(oe, a2) {
          R2.resolve(oe).then(s, function(v) {
            B || (B = true, S2.reject($2, v));
          });
          function s(v) {
            H2[a2] = v, ++j2 === I2 && !B && (B = true, S2.resolve($2, H2));
          }
        }
      }
      m3.race = re;
      function re(h2) {
        var R2 = this;
        if (Object.prototype.toString.call(h2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var I2 = h2.length, B = false;
        if (!I2)
          return this.resolve([]);
        for (var H2 = -1, j2 = new this(Y2); ++H2 < I2; )
          J(h2[H2]);
        return j2;
        function J($2) {
          R2.resolve($2).then(function(ee2) {
            B || (B = true, S2.resolve(j2, ee2));
          }, function(ee2) {
            B || (B = true, S2.reject(j2, ee2));
          });
        }
      }
    }, { "1": 1 }], 3: [function(L2, M, Q2) {
      (function(C2) {
        "use strict";
        typeof C2.Promise != "function" && (C2.Promise = L2(2));
      }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(L2, M, Q2) {
      "use strict";
      var C2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e;
      } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };
      function Y2(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      function S2() {
        try {
          if (typeof indexedDB != "undefined")
            return indexedDB;
          if (typeof webkitIndexedDB != "undefined")
            return webkitIndexedDB;
          if (typeof mozIndexedDB != "undefined")
            return mozIndexedDB;
          if (typeof OIndexedDB != "undefined")
            return OIndexedDB;
          if (typeof msIndexedDB != "undefined")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var P2 = S2();
      function K2() {
        try {
          if (!P2 || !P2.open)
            return false;
          var e = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), t = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!e || t) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
        } catch {
          return false;
        }
      }
      function Z2(e, t) {
        e = e || [], t = t || {};
        try {
          return new Blob(e, t);
        } catch (n) {
          if (n.name !== "TypeError")
            throw n;
          for (var r = typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder, o2 = new r(), i = 0; i < e.length; i += 1)
            o2.append(e[i]);
          return o2.getBlob(t.type);
        }
      }
      typeof Promise == "undefined" && L2(3);
      var m3 = Promise;
      function w2(e, t) {
        t && e.then(function(r) {
          t(null, r);
        }, function(r) {
          t(r);
        });
      }
      function N2(e, t, r) {
        typeof t == "function" && e.then(t), typeof r == "function" && e.catch(r);
      }
      function z2(e) {
        return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
      }
      function q2() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var F2 = "local-forage-detect-blob-support", k2 = void 0, U2 = {}, ae2 = Object.prototype.toString, re = "readonly", h2 = "readwrite";
      function R2(e) {
        for (var t = e.length, r = new ArrayBuffer(t), o2 = new Uint8Array(r), i = 0; i < t; i++)
          o2[i] = e.charCodeAt(i);
        return r;
      }
      function I2(e) {
        return new m3(function(t) {
          var r = e.transaction(F2, h2), o2 = Z2([""]);
          r.objectStore(F2).put(o2, "key"), r.onabort = function(i) {
            i.preventDefault(), i.stopPropagation(), t(false);
          }, r.oncomplete = function() {
            var i = navigator.userAgent.match(/Chrome\/(\d+)/), n = navigator.userAgent.match(/Edge\//);
            t(n || !i || parseInt(i[1], 10) >= 43);
          };
        }).catch(function() {
          return false;
        });
      }
      function B(e) {
        return typeof k2 == "boolean" ? m3.resolve(k2) : I2(e).then(function(t) {
          return k2 = t, k2;
        });
      }
      function H2(e) {
        var t = U2[e.name], r = {};
        r.promise = new m3(function(o2, i) {
          r.resolve = o2, r.reject = i;
        }), t.deferredOperations.push(r), t.dbReady ? t.dbReady = t.dbReady.then(function() {
          return r.promise;
        }) : t.dbReady = r.promise;
      }
      function j2(e) {
        var t = U2[e.name], r = t.deferredOperations.pop();
        if (r)
          return r.resolve(), r.promise;
      }
      function J(e, t) {
        var r = U2[e.name], o2 = r.deferredOperations.pop();
        if (o2)
          return o2.reject(t), o2.promise;
      }
      function $2(e, t) {
        return new m3(function(r, o2) {
          if (U2[e.name] = U2[e.name] || G2(), e.db)
            if (t)
              H2(e), e.db.close();
            else
              return r(e.db);
          var i = [e.name];
          t && i.push(e.version);
          var n = P2.open.apply(P2, i);
          t && (n.onupgradeneeded = function(f2) {
            var u2 = n.result;
            try {
              u2.createObjectStore(e.storeName), f2.oldVersion <= 1 && u2.createObjectStore(F2);
            } catch (c) {
              if (c.name === "ConstraintError")
                console.warn('The database "' + e.name + '" has been upgraded from version ' + f2.oldVersion + " to version " + f2.newVersion + ', but the storage "' + e.storeName + '" already exists.');
              else
                throw c;
            }
          }), n.onerror = function(f2) {
            f2.preventDefault(), o2(n.error);
          }, n.onsuccess = function() {
            r(n.result), j2(e);
          };
        });
      }
      function ee2(e) {
        return $2(e, false);
      }
      function oe(e) {
        return $2(e, true);
      }
      function a2(e, t) {
        if (!e.db)
          return true;
        var r = !e.db.objectStoreNames.contains(e.storeName), o2 = e.version < e.db.version, i = e.version > e.db.version;
        if (o2 && (e.version !== t && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), i || r) {
          if (r) {
            var n = e.db.version + 1;
            n > e.version && (e.version = n);
          }
          return true;
        }
        return false;
      }
      function s(e) {
        return new m3(function(t, r) {
          var o2 = new FileReader();
          o2.onerror = r, o2.onloadend = function(i) {
            var n = btoa(i.target.result || "");
            t({ __local_forage_encoded_blob: true, data: n, type: e.type });
          }, o2.readAsBinaryString(e);
        });
      }
      function v(e) {
        var t = R2(atob(e.data));
        return Z2([t], { type: e.type });
      }
      function b2(e) {
        return e && e.__local_forage_encoded_blob;
      }
      function _2(e) {
        var t = this, r = t._initReady().then(function() {
          var o2 = U2[t._dbInfo.name];
          if (o2 && o2.dbReady)
            return o2.dbReady;
        });
        return N2(r, e, e), r;
      }
      function E2(e) {
        H2(e);
        for (var t = U2[e.name], r = t.forages, o2 = 0; o2 < r.length; o2++) {
          var i = r[o2];
          i._dbInfo.db && (i._dbInfo.db.close(), i._dbInfo.db = null);
        }
        return e.db = null, ee2(e).then(function(n) {
          return e.db = n, a2(e) ? oe(e) : n;
        }).then(function(n) {
          e.db = t.db = n;
          for (var f2 = 0; f2 < r.length; f2++)
            r[f2]._dbInfo.db = n;
        }).catch(function(n) {
          throw J(e, n), n;
        });
      }
      function D2(e, t, r, o2) {
        o2 === void 0 && (o2 = 1);
        try {
          var i = e.db.transaction(e.storeName, t);
          r(null, i);
        } catch (n) {
          if (o2 > 0 && (!e.db || n.name === "InvalidStateError" || n.name === "NotFoundError"))
            return m3.resolve().then(function() {
              if (!e.db || n.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version)
                return e.db && (e.version = e.db.version + 1), oe(e);
            }).then(function() {
              return E2(e).then(function() {
                D2(e, t, r, o2 - 1);
              });
            }).catch(r);
          r(n);
        }
      }
      function G2() {
        return { forages: [], db: null, dbReady: null, deferredOperations: [] };
      }
      function fe(e) {
        var t = this, r = { db: null };
        if (e)
          for (var o2 in e)
            r[o2] = e[o2];
        var i = U2[r.name];
        i || (i = G2(), U2[r.name] = i), i.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = _2);
        var n = [];
        function f2() {
          return m3.resolve();
        }
        for (var u2 = 0; u2 < i.forages.length; u2++) {
          var c = i.forages[u2];
          c !== t && n.push(c._initReady().catch(f2));
        }
        var l2 = i.forages.slice(0);
        return m3.all(n).then(function() {
          return r.db = i.db, ee2(r);
        }).then(function(d2) {
          return r.db = d2, a2(r, t._defaultConfig.version) ? oe(r) : d2;
        }).then(function(d2) {
          r.db = i.db = d2, t._dbInfo = r;
          for (var y = 0; y < l2.length; y++) {
            var A = l2[y];
            A !== t && (A._dbInfo.db = r.db, A._dbInfo.version = r.version);
          }
        });
      }
      function ie2(e, t) {
        var r = this;
        e = z2(e);
        var o2 = new m3(function(i, n) {
          r.ready().then(function() {
            D2(r._dbInfo, re, function(f2, u2) {
              if (f2)
                return n(f2);
              try {
                var c = u2.objectStore(r._dbInfo.storeName), l2 = c.get(e);
                l2.onsuccess = function() {
                  var d2 = l2.result;
                  d2 === void 0 && (d2 = null), b2(d2) && (d2 = v(d2)), i(d2);
                }, l2.onerror = function() {
                  n(l2.error);
                };
              } catch (d2) {
                n(d2);
              }
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function ce2(e, t) {
        var r = this, o2 = new m3(function(i, n) {
          r.ready().then(function() {
            D2(r._dbInfo, re, function(f2, u2) {
              if (f2)
                return n(f2);
              try {
                var c = u2.objectStore(r._dbInfo.storeName), l2 = c.openCursor(), d2 = 1;
                l2.onsuccess = function() {
                  var y = l2.result;
                  if (y) {
                    var A = y.value;
                    b2(A) && (A = v(A));
                    var T = e(A, y.key, d2++);
                    T !== void 0 ? i(T) : y.continue();
                  } else
                    i();
                }, l2.onerror = function() {
                  n(l2.error);
                };
              } catch (y) {
                n(y);
              }
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function nr(e, t, r) {
        var o2 = this;
        e = z2(e);
        var i = new m3(function(n, f2) {
          var u2;
          o2.ready().then(function() {
            return u2 = o2._dbInfo, ae2.call(t) === "[object Blob]" ? B(u2.db).then(function(c) {
              return c ? t : s(t);
            }) : t;
          }).then(function(c) {
            D2(o2._dbInfo, h2, function(l2, d2) {
              if (l2)
                return f2(l2);
              try {
                var y = d2.objectStore(o2._dbInfo.storeName);
                c === null && (c = void 0);
                var A = y.put(c, e);
                d2.oncomplete = function() {
                  c === void 0 && (c = null), n(c);
                }, d2.onabort = d2.onerror = function() {
                  var T = A.error ? A.error : A.transaction.error;
                  f2(T);
                };
              } catch (T) {
                f2(T);
              }
            });
          }).catch(f2);
        });
        return w2(i, r), i;
      }
      function or(e, t) {
        var r = this;
        e = z2(e);
        var o2 = new m3(function(i, n) {
          r.ready().then(function() {
            D2(r._dbInfo, h2, function(f2, u2) {
              if (f2)
                return n(f2);
              try {
                var c = u2.objectStore(r._dbInfo.storeName), l2 = c.delete(e);
                u2.oncomplete = function() {
                  i();
                }, u2.onerror = function() {
                  n(l2.error);
                }, u2.onabort = function() {
                  var d2 = l2.error ? l2.error : l2.transaction.error;
                  n(d2);
                };
              } catch (d2) {
                n(d2);
              }
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function ir(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            D2(t._dbInfo, h2, function(n, f2) {
              if (n)
                return i(n);
              try {
                var u2 = f2.objectStore(t._dbInfo.storeName), c = u2.clear();
                f2.oncomplete = function() {
                  o2();
                }, f2.onabort = f2.onerror = function() {
                  var l2 = c.error ? c.error : c.transaction.error;
                  i(l2);
                };
              } catch (l2) {
                i(l2);
              }
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function ar(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            D2(t._dbInfo, re, function(n, f2) {
              if (n)
                return i(n);
              try {
                var u2 = f2.objectStore(t._dbInfo.storeName), c = u2.count();
                c.onsuccess = function() {
                  o2(c.result);
                }, c.onerror = function() {
                  i(c.error);
                };
              } catch (l2) {
                i(l2);
              }
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function fr(e, t) {
        var r = this, o2 = new m3(function(i, n) {
          if (e < 0) {
            i(null);
            return;
          }
          r.ready().then(function() {
            D2(r._dbInfo, re, function(f2, u2) {
              if (f2)
                return n(f2);
              try {
                var c = u2.objectStore(r._dbInfo.storeName), l2 = false, d2 = c.openKeyCursor();
                d2.onsuccess = function() {
                  var y = d2.result;
                  if (!y) {
                    i(null);
                    return;
                  }
                  e === 0 || l2 ? i(y.key) : (l2 = true, y.advance(e));
                }, d2.onerror = function() {
                  n(d2.error);
                };
              } catch (y) {
                n(y);
              }
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function ur(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            D2(t._dbInfo, re, function(n, f2) {
              if (n)
                return i(n);
              try {
                var u2 = f2.objectStore(t._dbInfo.storeName), c = u2.openKeyCursor(), l2 = [];
                c.onsuccess = function() {
                  var d2 = c.result;
                  if (!d2) {
                    o2(l2);
                    return;
                  }
                  l2.push(d2.key), d2.continue();
                }, c.onerror = function() {
                  i(c.error);
                };
              } catch (d2) {
                i(d2);
              }
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function sr(e, t) {
        t = q2.apply(this, arguments);
        var r = this.config();
        e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
        var o2 = this, i;
        if (!e.name)
          i = m3.reject("Invalid arguments");
        else {
          var n = e.name === r.name && o2._dbInfo.db, f2 = n ? m3.resolve(o2._dbInfo.db) : ee2(e).then(function(u2) {
            var c = U2[e.name], l2 = c.forages;
            c.db = u2;
            for (var d2 = 0; d2 < l2.length; d2++)
              l2[d2]._dbInfo.db = u2;
            return u2;
          });
          e.storeName ? i = f2.then(function(u2) {
            if (!!u2.objectStoreNames.contains(e.storeName)) {
              var c = u2.version + 1;
              H2(e);
              var l2 = U2[e.name], d2 = l2.forages;
              u2.close();
              for (var y = 0; y < d2.length; y++) {
                var A = d2[y];
                A._dbInfo.db = null, A._dbInfo.version = c;
              }
              var T = new m3(function(x, V2) {
                var W2 = P2.open(e.name, c);
                W2.onerror = function(X2) {
                  var de = W2.result;
                  de.close(), V2(X2);
                }, W2.onupgradeneeded = function() {
                  var X2 = W2.result;
                  X2.deleteObjectStore(e.storeName);
                }, W2.onsuccess = function() {
                  var X2 = W2.result;
                  X2.close(), x(X2);
                };
              });
              return T.then(function(x) {
                l2.db = x;
                for (var V2 = 0; V2 < d2.length; V2++) {
                  var W2 = d2[V2];
                  W2._dbInfo.db = x, j2(W2._dbInfo);
                }
              }).catch(function(x) {
                throw (J(e, x) || m3.resolve()).catch(function() {
                }), x;
              });
            }
          }) : i = f2.then(function(u2) {
            H2(e);
            var c = U2[e.name], l2 = c.forages;
            u2.close();
            for (var d2 = 0; d2 < l2.length; d2++) {
              var y = l2[d2];
              y._dbInfo.db = null;
            }
            var A = new m3(function(T, x) {
              var V2 = P2.deleteDatabase(e.name);
              V2.onerror = V2.onblocked = function(W2) {
                var X2 = V2.result;
                X2 && X2.close(), x(W2);
              }, V2.onsuccess = function() {
                var W2 = V2.result;
                W2 && W2.close(), T(W2);
              };
            });
            return A.then(function(T) {
              c.db = T;
              for (var x = 0; x < l2.length; x++) {
                var V2 = l2[x];
                j2(V2._dbInfo);
              }
            }).catch(function(T) {
              throw (J(e, T) || m3.resolve()).catch(function() {
              }), T;
            });
          });
        }
        return w2(i, t), i;
      }
      var cr2 = { _driver: "asyncStorage", _initStorage: fe, _support: K2(), iterate: ce2, getItem: ie2, setItem: nr, removeItem: or, clear: ir, length: ar, key: fr, keys: ur, dropInstance: sr };
      function lr2() {
        return typeof openDatabase == "function";
      }
      var te2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", dr = "~~local_forage_type~", xe2 = /^~~local_forage_type~([^~]+)~/, he2 = "__lfsc__:", ge2 = he2.length, be2 = "arbf", _e2 = "blob", Oe2 = "si08", Ce2 = "ui08", Le2 = "uic8", Pe2 = "si16", Me2 = "si32", Fe2 = "ur16", Ue2 = "ui32", Ye2 = "fl32", ze2 = "fl64", We2 = ge2 + be2.length, Ke2 = Object.prototype.toString;
      function He2(e) {
        var t = e.length * 0.75, r = e.length, o2, i = 0, n, f2, u2, c;
        e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
        var l2 = new ArrayBuffer(t), d2 = new Uint8Array(l2);
        for (o2 = 0; o2 < r; o2 += 4)
          n = te2.indexOf(e[o2]), f2 = te2.indexOf(e[o2 + 1]), u2 = te2.indexOf(e[o2 + 2]), c = te2.indexOf(e[o2 + 3]), d2[i++] = n << 2 | f2 >> 4, d2[i++] = (f2 & 15) << 4 | u2 >> 2, d2[i++] = (u2 & 3) << 6 | c & 63;
        return l2;
      }
      function we2(e) {
        var t = new Uint8Array(e), r = "", o2;
        for (o2 = 0; o2 < t.length; o2 += 3)
          r += te2[t[o2] >> 2], r += te2[(t[o2] & 3) << 4 | t[o2 + 1] >> 4], r += te2[(t[o2 + 1] & 15) << 2 | t[o2 + 2] >> 6], r += te2[t[o2 + 2] & 63];
        return t.length % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t.length % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
      }
      function vr(e, t) {
        var r = "";
        if (e && (r = Ke2.call(e)), e && (r === "[object ArrayBuffer]" || e.buffer && Ke2.call(e.buffer) === "[object ArrayBuffer]")) {
          var o2, i = he2;
          e instanceof ArrayBuffer ? (o2 = e, i += be2) : (o2 = e.buffer, r === "[object Int8Array]" ? i += Oe2 : r === "[object Uint8Array]" ? i += Ce2 : r === "[object Uint8ClampedArray]" ? i += Le2 : r === "[object Int16Array]" ? i += Pe2 : r === "[object Uint16Array]" ? i += Fe2 : r === "[object Int32Array]" ? i += Me2 : r === "[object Uint32Array]" ? i += Ue2 : r === "[object Float32Array]" ? i += Ye2 : r === "[object Float64Array]" ? i += ze2 : t(new Error("Failed to get type for BinaryArray"))), t(i + we2(o2));
        } else if (r === "[object Blob]") {
          var n = new FileReader();
          n.onload = function() {
            var f2 = dr + e.type + "~" + we2(this.result);
            t(he2 + _e2 + f2);
          }, n.readAsArrayBuffer(e);
        } else
          try {
            t(JSON.stringify(e));
          } catch (f2) {
            console.error("Couldn't convert value into a JSON string: ", e), t(null, f2);
          }
      }
      function hr(e) {
        if (e.substring(0, ge2) !== he2)
          return JSON.parse(e);
        var t = e.substring(We2), r = e.substring(ge2, We2), o2;
        if (r === _e2 && xe2.test(t)) {
          var i = t.match(xe2);
          o2 = i[1], t = t.substring(i[0].length);
        }
        var n = He2(t);
        switch (r) {
          case be2:
            return n;
          case _e2:
            return Z2([n], { type: o2 });
          case Oe2:
            return new Int8Array(n);
          case Ce2:
            return new Uint8Array(n);
          case Le2:
            return new Uint8ClampedArray(n);
          case Pe2:
            return new Int16Array(n);
          case Fe2:
            return new Uint16Array(n);
          case Me2:
            return new Int32Array(n);
          case Ue2:
            return new Uint32Array(n);
          case Ye2:
            return new Float32Array(n);
          case ze2:
            return new Float64Array(n);
          default:
            throw new Error("Unkown type: " + r);
        }
      }
      var Ee2 = { serialize: vr, deserialize: hr, stringToBuffer: He2, bufferToString: we2 };
      function Ve2(e, t, r, o2) {
        e.executeSql("CREATE TABLE IF NOT EXISTS " + t.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r, o2);
      }
      function mr(e) {
        var t = this, r = { db: null };
        if (e)
          for (var o2 in e)
            r[o2] = typeof e[o2] != "string" ? e[o2].toString() : e[o2];
        var i = new m3(function(n, f2) {
          try {
            r.db = openDatabase(r.name, String(r.version), r.description, r.size);
          } catch (u2) {
            return f2(u2);
          }
          r.db.transaction(function(u2) {
            Ve2(u2, r, function() {
              t._dbInfo = r, n();
            }, function(c, l2) {
              f2(l2);
            });
          }, f2);
        });
        return r.serializer = Ee2, i;
      }
      function ne2(e, t, r, o2, i, n) {
        e.executeSql(r, o2, i, function(f2, u2) {
          u2.code === u2.SYNTAX_ERR ? f2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function(c, l2) {
            l2.rows.length ? n(c, u2) : Ve2(c, t, function() {
              c.executeSql(r, o2, i, n);
            }, n);
          }, n) : n(f2, u2);
        }, n);
      }
      function yr(e, t) {
        var r = this;
        e = z2(e);
        var o2 = new m3(function(i, n) {
          r.ready().then(function() {
            var f2 = r._dbInfo;
            f2.db.transaction(function(u2) {
              ne2(u2, f2, "SELECT * FROM " + f2.storeName + " WHERE key = ? LIMIT 1", [e], function(c, l2) {
                var d2 = l2.rows.length ? l2.rows.item(0).value : null;
                d2 && (d2 = f2.serializer.deserialize(d2)), i(d2);
              }, function(c, l2) {
                n(l2);
              });
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function pr(e, t) {
        var r = this, o2 = new m3(function(i, n) {
          r.ready().then(function() {
            var f2 = r._dbInfo;
            f2.db.transaction(function(u2) {
              ne2(u2, f2, "SELECT * FROM " + f2.storeName, [], function(c, l2) {
                for (var d2 = l2.rows, y = d2.length, A = 0; A < y; A++) {
                  var T = d2.item(A), x = T.value;
                  if (x && (x = f2.serializer.deserialize(x)), x = e(x, T.key, A + 1), x !== void 0) {
                    i(x);
                    return;
                  }
                }
                i();
              }, function(c, l2) {
                n(l2);
              });
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function Ge2(e, t, r, o2) {
        var i = this;
        e = z2(e);
        var n = new m3(function(f2, u2) {
          i.ready().then(function() {
            t === void 0 && (t = null);
            var c = t, l2 = i._dbInfo;
            l2.serializer.serialize(t, function(d2, y) {
              y ? u2(y) : l2.db.transaction(function(A) {
                ne2(A, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [e, d2], function() {
                  f2(c);
                }, function(T, x) {
                  u2(x);
                });
              }, function(A) {
                if (A.code === A.QUOTA_ERR) {
                  if (o2 > 0) {
                    f2(Ge2.apply(i, [e, c, r, o2 - 1]));
                    return;
                  }
                  u2(A);
                }
              });
            });
          }).catch(u2);
        });
        return w2(n, r), n;
      }
      function gr(e, t, r) {
        return Ge2.apply(this, [e, t, r, 1]);
      }
      function br(e, t) {
        var r = this;
        e = z2(e);
        var o2 = new m3(function(i, n) {
          r.ready().then(function() {
            var f2 = r._dbInfo;
            f2.db.transaction(function(u2) {
              ne2(u2, f2, "DELETE FROM " + f2.storeName + " WHERE key = ?", [e], function() {
                i();
              }, function(c, l2) {
                n(l2);
              });
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function _r(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            var n = t._dbInfo;
            n.db.transaction(function(f2) {
              ne2(f2, n, "DELETE FROM " + n.storeName, [], function() {
                o2();
              }, function(u2, c) {
                i(c);
              });
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function wr(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            var n = t._dbInfo;
            n.db.transaction(function(f2) {
              ne2(f2, n, "SELECT COUNT(key) as c FROM " + n.storeName, [], function(u2, c) {
                var l2 = c.rows.item(0).c;
                o2(l2);
              }, function(u2, c) {
                i(c);
              });
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function Er(e, t) {
        var r = this, o2 = new m3(function(i, n) {
          r.ready().then(function() {
            var f2 = r._dbInfo;
            f2.db.transaction(function(u2) {
              ne2(u2, f2, "SELECT key FROM " + f2.storeName + " WHERE id = ? LIMIT 1", [e + 1], function(c, l2) {
                var d2 = l2.rows.length ? l2.rows.item(0).key : null;
                i(d2);
              }, function(c, l2) {
                n(l2);
              });
            });
          }).catch(n);
        });
        return w2(o2, t), o2;
      }
      function Ir(e) {
        var t = this, r = new m3(function(o2, i) {
          t.ready().then(function() {
            var n = t._dbInfo;
            n.db.transaction(function(f2) {
              ne2(f2, n, "SELECT key FROM " + n.storeName, [], function(u2, c) {
                for (var l2 = [], d2 = 0; d2 < c.rows.length; d2++)
                  l2.push(c.rows.item(d2).key);
                o2(l2);
              }, function(u2, c) {
                i(c);
              });
            });
          }).catch(i);
        });
        return w2(r, e), r;
      }
      function Sr(e) {
        return new m3(function(t, r) {
          e.transaction(function(o2) {
            o2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(i, n) {
              for (var f2 = [], u2 = 0; u2 < n.rows.length; u2++)
                f2.push(n.rows.item(u2).name);
              t({ db: e, storeNames: f2 });
            }, function(i, n) {
              r(n);
            });
          }, function(o2) {
            r(o2);
          });
        });
      }
      function Ar(e, t) {
        t = q2.apply(this, arguments);
        var r = this.config();
        e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
        var o2 = this, i;
        return e.name ? i = new m3(function(n) {
          var f2;
          e.name === r.name ? f2 = o2._dbInfo.db : f2 = openDatabase(e.name, "", "", 0), e.storeName ? n({ db: f2, storeNames: [e.storeName] }) : n(Sr(f2));
        }).then(function(n) {
          return new m3(function(f2, u2) {
            n.db.transaction(function(c) {
              function l2(T) {
                return new m3(function(x, V2) {
                  c.executeSql("DROP TABLE IF EXISTS " + T, [], function() {
                    x();
                  }, function(W2, X2) {
                    V2(X2);
                  });
                });
              }
              for (var d2 = [], y = 0, A = n.storeNames.length; y < A; y++)
                d2.push(l2(n.storeNames[y]));
              m3.all(d2).then(function() {
                f2();
              }).catch(function(T) {
                u2(T);
              });
            }, function(c) {
              u2(c);
            });
          });
        }) : i = m3.reject("Invalid arguments"), w2(i, t), i;
      }
      var Rr = { _driver: "webSQLStorage", _initStorage: mr, _support: lr2(), iterate: pr, getItem: yr, setItem: gr, removeItem: br, clear: _r, length: wr, key: Er, keys: Ir, dropInstance: Ar };
      function Dr() {
        try {
          return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
        } catch {
          return false;
        }
      }
      function je2(e, t) {
        var r = e.name + "/";
        return e.storeName !== t.storeName && (r += e.storeName + "/"), r;
      }
      function Nr() {
        var e = "_localforage_support_test";
        try {
          return localStorage.setItem(e, true), localStorage.removeItem(e), false;
        } catch {
          return true;
        }
      }
      function Tr() {
        return !Nr() || localStorage.length > 0;
      }
      function Br(e) {
        var t = this, r = {};
        if (e)
          for (var o2 in e)
            r[o2] = e[o2];
        return r.keyPrefix = je2(e, t._defaultConfig), Tr() ? (t._dbInfo = r, r.serializer = Ee2, m3.resolve()) : m3.reject();
      }
      function xr(e) {
        var t = this, r = t.ready().then(function() {
          for (var o2 = t._dbInfo.keyPrefix, i = localStorage.length - 1; i >= 0; i--) {
            var n = localStorage.key(i);
            n.indexOf(o2) === 0 && localStorage.removeItem(n);
          }
        });
        return w2(r, e), r;
      }
      function Or(e, t) {
        var r = this;
        e = z2(e);
        var o2 = r.ready().then(function() {
          var i = r._dbInfo, n = localStorage.getItem(i.keyPrefix + e);
          return n && (n = i.serializer.deserialize(n)), n;
        });
        return w2(o2, t), o2;
      }
      function Cr(e, t) {
        var r = this, o2 = r.ready().then(function() {
          for (var i = r._dbInfo, n = i.keyPrefix, f2 = n.length, u2 = localStorage.length, c = 1, l2 = 0; l2 < u2; l2++) {
            var d2 = localStorage.key(l2);
            if (d2.indexOf(n) === 0) {
              var y = localStorage.getItem(d2);
              if (y && (y = i.serializer.deserialize(y)), y = e(y, d2.substring(f2), c++), y !== void 0)
                return y;
            }
          }
        });
        return w2(o2, t), o2;
      }
      function Lr(e, t) {
        var r = this, o2 = r.ready().then(function() {
          var i = r._dbInfo, n;
          try {
            n = localStorage.key(e);
          } catch {
            n = null;
          }
          return n && (n = n.substring(i.keyPrefix.length)), n;
        });
        return w2(o2, t), o2;
      }
      function Pr(e) {
        var t = this, r = t.ready().then(function() {
          for (var o2 = t._dbInfo, i = localStorage.length, n = [], f2 = 0; f2 < i; f2++) {
            var u2 = localStorage.key(f2);
            u2.indexOf(o2.keyPrefix) === 0 && n.push(u2.substring(o2.keyPrefix.length));
          }
          return n;
        });
        return w2(r, e), r;
      }
      function Mr(e) {
        var t = this, r = t.keys().then(function(o2) {
          return o2.length;
        });
        return w2(r, e), r;
      }
      function Fr(e, t) {
        var r = this;
        e = z2(e);
        var o2 = r.ready().then(function() {
          var i = r._dbInfo;
          localStorage.removeItem(i.keyPrefix + e);
        });
        return w2(o2, t), o2;
      }
      function Ur(e, t, r) {
        var o2 = this;
        e = z2(e);
        var i = o2.ready().then(function() {
          t === void 0 && (t = null);
          var n = t;
          return new m3(function(f2, u2) {
            var c = o2._dbInfo;
            c.serializer.serialize(t, function(l2, d2) {
              if (d2)
                u2(d2);
              else
                try {
                  localStorage.setItem(c.keyPrefix + e, l2), f2(n);
                } catch (y) {
                  (y.name === "QuotaExceededError" || y.name === "NS_ERROR_DOM_QUOTA_REACHED") && u2(y), u2(y);
                }
            });
          });
        });
        return w2(i, r), i;
      }
      function Yr(e, t) {
        if (t = q2.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
          var r = this.config();
          e.name = e.name || r.name, e.storeName = e.storeName || r.storeName;
        }
        var o2 = this, i;
        return e.name ? i = new m3(function(n) {
          e.storeName ? n(je2(e, o2._defaultConfig)) : n(e.name + "/");
        }).then(function(n) {
          for (var f2 = localStorage.length - 1; f2 >= 0; f2--) {
            var u2 = localStorage.key(f2);
            u2.indexOf(n) === 0 && localStorage.removeItem(u2);
          }
        }) : i = m3.reject("Invalid arguments"), w2(i, t), i;
      }
      var zr = { _driver: "localStorageWrapper", _initStorage: Br, _support: Dr(), iterate: Cr, getItem: Or, setItem: Ur, removeItem: Fr, clear: xr, length: Mr, key: Lr, keys: Pr, dropInstance: Yr }, Wr = function(t, r) {
        return t === r || typeof t == "number" && typeof r == "number" && isNaN(t) && isNaN(r);
      }, Kr = function(t, r) {
        for (var o2 = t.length, i = 0; i < o2; ) {
          if (Wr(t[i], r))
            return true;
          i++;
        }
        return false;
      }, Xe2 = Array.isArray || function(e) {
        return Object.prototype.toString.call(e) === "[object Array]";
      }, le2 = {}, Qe2 = {}, ue2 = { INDEXEDDB: cr2, WEBSQL: Rr, LOCALSTORAGE: zr }, Hr = [ue2.INDEXEDDB._driver, ue2.WEBSQL._driver, ue2.LOCALSTORAGE._driver], me2 = ["dropInstance"], Ie2 = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(me2), Vr = { description: "", driver: Hr.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
      function Gr(e, t) {
        e[t] = function() {
          var r = arguments;
          return e.ready().then(function() {
            return e[t].apply(e, r);
          });
        };
      }
      function Se2() {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          if (t)
            for (var r in t)
              t.hasOwnProperty(r) && (Xe2(t[r]) ? arguments[0][r] = t[r].slice() : arguments[0][r] = t[r]);
        }
        return arguments[0];
      }
      var jr = function() {
        function e(t) {
          Y2(this, e);
          for (var r in ue2)
            if (ue2.hasOwnProperty(r)) {
              var o2 = ue2[r], i = o2._driver;
              this[r] = i, le2[i] || this.defineDriver(o2);
            }
          this._defaultConfig = Se2({}, Vr), this._config = Se2({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return e.prototype.config = function(r) {
          if ((typeof r == "undefined" ? "undefined" : C2(r)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var o2 in r) {
              if (o2 === "storeName" && (r[o2] = r[o2].replace(/\W/g, "_")), o2 === "version" && typeof r[o2] != "number")
                return new Error("Database version must be a number.");
              this._config[o2] = r[o2];
            }
            return "driver" in r && r.driver ? this.setDriver(this._config.driver) : true;
          } else
            return typeof r == "string" ? this._config[r] : this._config;
        }, e.prototype.defineDriver = function(r, o2, i) {
          var n = new m3(function(f2, u2) {
            try {
              var c = r._driver, l2 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!r._driver) {
                u2(l2);
                return;
              }
              for (var d2 = Ie2.concat("_initStorage"), y = 0, A = d2.length; y < A; y++) {
                var T = d2[y], x = !Kr(me2, T);
                if ((x || r[T]) && typeof r[T] != "function") {
                  u2(l2);
                  return;
                }
              }
              var V2 = function() {
                for (var de = function(Jr) {
                  return function() {
                    var $r = new Error("Method " + Jr + " is not implemented by the current driver"), Je2 = m3.reject($r);
                    return w2(Je2, arguments[arguments.length - 1]), Je2;
                  };
                }, Ae2 = 0, Qr = me2.length; Ae2 < Qr; Ae2++) {
                  var Re2 = me2[Ae2];
                  r[Re2] || (r[Re2] = de(Re2));
                }
              };
              V2();
              var W2 = function(de) {
                le2[c] && console.info("Redefining LocalForage driver: " + c), le2[c] = r, Qe2[c] = de, f2();
              };
              "_support" in r ? r._support && typeof r._support == "function" ? r._support().then(W2, u2) : W2(!!r._support) : W2(true);
            } catch (X2) {
              u2(X2);
            }
          });
          return N2(n, o2, i), n;
        }, e.prototype.driver = function() {
          return this._driver || null;
        }, e.prototype.getDriver = function(r, o2, i) {
          var n = le2[r] ? m3.resolve(le2[r]) : m3.reject(new Error("Driver not found."));
          return N2(n, o2, i), n;
        }, e.prototype.getSerializer = function(r) {
          var o2 = m3.resolve(Ee2);
          return N2(o2, r), o2;
        }, e.prototype.ready = function(r) {
          var o2 = this, i = o2._driverSet.then(function() {
            return o2._ready === null && (o2._ready = o2._initDriver()), o2._ready;
          });
          return N2(i, r, r), i;
        }, e.prototype.setDriver = function(r, o2, i) {
          var n = this;
          Xe2(r) || (r = [r]);
          var f2 = this._getSupportedDrivers(r);
          function u2() {
            n._config.driver = n.driver();
          }
          function c(y) {
            return n._extend(y), u2(), n._ready = n._initStorage(n._config), n._ready;
          }
          function l2(y) {
            return function() {
              var A = 0;
              function T() {
                for (; A < y.length; ) {
                  var x = y[A];
                  return A++, n._dbInfo = null, n._ready = null, n.getDriver(x).then(c).catch(T);
                }
                u2();
                var V2 = new Error("No available storage method found.");
                return n._driverSet = m3.reject(V2), n._driverSet;
              }
              return T();
            };
          }
          var d2 = this._driverSet !== null ? this._driverSet.catch(function() {
            return m3.resolve();
          }) : m3.resolve();
          return this._driverSet = d2.then(function() {
            var y = f2[0];
            return n._dbInfo = null, n._ready = null, n.getDriver(y).then(function(A) {
              n._driver = A._driver, u2(), n._wrapLibraryMethodsWithReady(), n._initDriver = l2(f2);
            });
          }).catch(function() {
            u2();
            var y = new Error("No available storage method found.");
            return n._driverSet = m3.reject(y), n._driverSet;
          }), N2(this._driverSet, o2, i), this._driverSet;
        }, e.prototype.supports = function(r) {
          return !!Qe2[r];
        }, e.prototype._extend = function(r) {
          Se2(this, r);
        }, e.prototype._getSupportedDrivers = function(r) {
          for (var o2 = [], i = 0, n = r.length; i < n; i++) {
            var f2 = r[i];
            this.supports(f2) && o2.push(f2);
          }
          return o2;
        }, e.prototype._wrapLibraryMethodsWithReady = function() {
          for (var r = 0, o2 = Ie2.length; r < o2; r++)
            Gr(this, Ie2[r]);
        }, e.prototype.createInstance = function(r) {
          return new e(r);
        }, e;
      }(), Xr = new jr();
      M.exports = Xr;
    }, { "3": 3 }] }, {}, [4])(4);
  });
});
var rr = $e2((ye2, er) => {
  (function(p2, g3) {
    typeof ye2 == "object" && typeof er != "undefined" ? g3(ye2) : typeof define == "function" && define.amd ? define("localforage-driver-memory", ["exports"], g3) : g3(p2.LocalforageDriverMemory = {});
  })(typeof self != "undefined" ? self : ye2, function(p2) {
    "use strict";
    var g3 = "localforage-driver-memory";
    function O2(a2) {
      var s = typeof Symbol == "function" && a2[Symbol.iterator], v = 0;
      return s ? s.call(a2) : { next: function() {
        return a2 && v >= a2.length && (a2 = void 0), { value: a2 && a2[v++], done: !a2 };
      } };
    }
    function L2(a2, s) {
      a2 = a2 || [], s = s || {};
      try {
        return new Blob(a2, s);
      } catch (E2) {
        if (E2.name !== "TypeError")
          throw E2;
        for (var v = typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder, b2 = new v(), _2 = 0; _2 < a2.length; _2 += 1)
          b2.append(a2[_2]);
        return b2.getBlob(s.type);
      }
    }
    var M = /^~~local_forage_type~([^~]+)~/, Q2 = "__lfsc__:".length, C2 = Q2 + "arbf".length, Y2 = Object.prototype.toString;
    function S2(a2) {
      var s = a2.length * 0.75, v = a2.length;
      a2[a2.length - 1] === "=" && (s--, a2[a2.length - 2] === "=" && s--);
      for (var b2 = new ArrayBuffer(s), _2 = new Uint8Array(b2), E2 = 0, D2 = 0; E2 < v; E2 += 4) {
        var G2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[E2]), fe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[E2 + 1]), ie2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[E2 + 2]), ce2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[E2 + 3]);
        _2[D2++] = G2 << 2 | fe >> 4, _2[D2++] = (fe & 15) << 4 | ie2 >> 2, _2[D2++] = (ie2 & 3) << 6 | ce2 & 63;
      }
      return b2;
    }
    function P2(a2) {
      for (var s = new Uint8Array(a2), v = "", b2 = 0; b2 < s.length; b2 += 3)
        v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s[b2] >> 2], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s[b2] & 3) << 4 | s[b2 + 1] >> 4], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s[b2 + 1] & 15) << 2 | s[b2 + 2] >> 6], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s[b2 + 2] & 63];
      return s.length % 3 === 2 ? v = v.substring(0, v.length - 1) + "=" : s.length % 3 === 1 && (v = v.substring(0, v.length - 2) + "=="), v;
    }
    function K2(a2, s) {
      var v = "";
      if (a2 && (v = Y2.call(a2)), a2 && (v === "[object ArrayBuffer]" || a2.buffer && Y2.call(a2.buffer) === "[object ArrayBuffer]")) {
        var b2 = void 0, _2 = "__lfsc__:";
        a2 instanceof ArrayBuffer ? (b2 = a2, _2 += "arbf") : (b2 = a2.buffer, v === "[object Int8Array]" ? _2 += "si08" : v === "[object Uint8Array]" ? _2 += "ui08" : v === "[object Uint8ClampedArray]" ? _2 += "uic8" : v === "[object Int16Array]" ? _2 += "si16" : v === "[object Uint16Array]" ? _2 += "ur16" : v === "[object Int32Array]" ? _2 += "si32" : v === "[object Uint32Array]" ? _2 += "ui32" : v === "[object Float32Array]" ? _2 += "fl32" : v === "[object Float64Array]" ? _2 += "fl64" : s(new Error("Failed to get type for BinaryArray"))), s(_2 + P2(b2));
      } else if (v === "[object Blob]") {
        var E2 = new FileReader();
        E2.onload = function() {
          var D2 = "~~local_forage_type~" + a2.type + "~" + P2(this.result);
          s("__lfsc__:blob" + D2);
        }, E2.readAsArrayBuffer(a2);
      } else
        try {
          s(JSON.stringify(a2));
        } catch (D2) {
          console.error("Couldn't convert value into a JSON string: ", a2), s(null, D2);
        }
    }
    function Z2(a2) {
      if (a2.substring(0, Q2) !== "__lfsc__:")
        return JSON.parse(a2);
      var s = a2.substring(C2), v = a2.substring(Q2, C2), b2;
      if (v === "blob" && M.test(s)) {
        var _2 = s.match(M);
        b2 = _2[1], s = s.substring(_2[0].length);
      }
      var E2 = S2(s);
      switch (v) {
        case "arbf":
          return E2;
        case "blob":
          return L2([E2], { type: b2 });
        case "si08":
          return new Int8Array(E2);
        case "ui08":
          return new Uint8Array(E2);
        case "uic8":
          return new Uint8ClampedArray(E2);
        case "si16":
          return new Int16Array(E2);
        case "ur16":
          return new Uint16Array(E2);
        case "si32":
          return new Int32Array(E2);
        case "ui32":
          return new Uint32Array(E2);
        case "fl32":
          return new Float32Array(E2);
        case "fl64":
          return new Float64Array(E2);
        default:
          throw new Error("Unkown type: " + v);
      }
    }
    function m3(a2) {
      var s, v;
      if (a2 === null || typeof a2 != "object" || "isActiveClone" in a2)
        return a2;
      var b2 = a2 instanceof Date ? new Date(a2) : a2.constructor();
      try {
        for (var _2 = O2(Object.keys(a2)), E2 = _2.next(); !E2.done; E2 = _2.next()) {
          var D2 = E2.value;
          Object.prototype.hasOwnProperty.call(a2, D2) && (a2.isActiveClone = null, b2[D2] = m3(a2[D2]), delete a2.isActiveClone);
        }
      } catch (G2) {
        s = { error: G2 };
      } finally {
        try {
          E2 && !E2.done && (v = _2.return) && v.call(_2);
        } finally {
          if (s)
            throw s.error;
        }
      }
      return b2;
    }
    function w2(a2, s) {
      return (a2.name || s.name) + "/" + (a2.storeName || s.storeName) + "/";
    }
    function N2(a2, s) {
      s && a2.then(function(v) {
        s(null, v);
      }, function(v) {
        s(v);
      });
    }
    function z2() {
      for (var a2 = [], s = 0; s < arguments.length; s++)
        a2[s] = arguments[s];
      if (arguments.length && typeof arguments[arguments.length - 1] == "function")
        return arguments[arguments.length - 1];
    }
    function q2(a2, s) {
      var v = this;
      if (s = z2.apply(this, arguments), a2 = typeof a2 != "function" && a2 || {}, !a2.name) {
        var b2 = this.config();
        a2.name = a2.name || b2.name, a2.storeName = a2.storeName || b2.storeName;
      }
      var _2;
      return a2.name ? _2 = new Promise(function(E2) {
        a2.storeName ? E2(w2(a2, v._defaultConfig)) : E2(a2.name + "/");
      }) : _2 = Promise.reject("Invalid arguments"), { promise: _2, callback: s };
    }
    function F2(a2) {
      return typeof a2 != "string" && (console.warn(a2 + " used as a key, but it is not a string."), a2 = String(a2)), a2;
    }
    var k2 = { bufferToString: P2, deserialize: Z2, serialize: K2, stringToBuffer: S2 }, U2 = {}, ae2 = function() {
      function a2(s) {
        this.kp = s, this.data = {};
      }
      return a2.resolve = function(s) {
        return U2[s] || (U2[s] = new a2(s)), U2[s];
      }, a2.prototype.clear = function() {
        this.data = {};
      }, a2.prototype.drop = function() {
        this.clear(), delete U2[this.kp];
      }, a2.prototype.get = function(s) {
        return this.data[s];
      }, a2.prototype.key = function(s) {
        return this.keys()[s];
      }, a2.prototype.keys = function() {
        return Object.keys(this.data);
      }, a2.prototype.rm = function(s) {
        delete this.data[s];
      }, a2.prototype.set = function(s, v) {
        this.data[s] = v;
      }, a2;
    }();
    function re(a2) {
      var s = a2 ? m3(a2) : {}, v = w2(s, this._defaultConfig), b2 = ae2.resolve(v);
      return this._dbInfo = s, this._dbInfo.serializer = k2, this._dbInfo.keyPrefix = v, this._dbInfo.mStore = b2, Promise.resolve();
    }
    function h2(a2) {
      var s = this, v = this.ready().then(function() {
        s._dbInfo.mStore.clear();
      });
      return N2(v, a2), v;
    }
    function R2(a2, s) {
      var v = q2.apply(this, arguments), b2 = v.promise, _2 = v.callback, E2 = b2.then(function(D2) {
        ae2.resolve(D2).drop();
      });
      return N2(E2, _2), b2;
    }
    function I2(a2, s) {
      var v = this;
      a2 = F2(a2);
      var b2 = this.ready().then(function() {
        var _2 = v._dbInfo.mStore.get(a2);
        return _2 == null ? null : v._dbInfo.serializer.deserialize(_2);
      });
      return N2(b2, s), b2;
    }
    function B(a2, s) {
      var v = this, b2 = this.ready().then(function() {
        for (var _2 = v._dbInfo.mStore, E2 = _2.keys(), D2 = 0; D2 < E2.length; D2++) {
          var G2 = _2.get(E2[D2]);
          if (G2 && (G2 = v._dbInfo.serializer.deserialize(G2)), G2 = a2(G2, E2[D2], D2 + 1), G2 !== void 0)
            return G2;
        }
      });
      return N2(b2, s), b2;
    }
    function H2(a2, s) {
      var v = this, b2 = this.ready().then(function() {
        var _2;
        try {
          _2 = v._dbInfo.mStore.key(a2), _2 === void 0 && (_2 = null);
        } catch {
          _2 = null;
        }
        return _2;
      });
      return N2(b2, s), b2;
    }
    function j2(a2) {
      var s = this, v = this.ready().then(function() {
        return s._dbInfo.mStore.keys();
      });
      return N2(v, a2), v;
    }
    function J(a2) {
      var s = this.keys().then(function(v) {
        return v.length;
      });
      return N2(s, a2), s;
    }
    function $2(a2, s) {
      var v = this;
      a2 = F2(a2);
      var b2 = this.ready().then(function() {
        v._dbInfo.mStore.rm(a2);
      });
      return N2(b2, s), b2;
    }
    function ee2(a2, s, v) {
      var b2 = this;
      a2 = F2(a2);
      var _2 = this.ready().then(function() {
        s === void 0 && (s = null);
        var E2 = s;
        return new Promise(function(D2, G2) {
          b2._dbInfo.serializer.serialize(s, function(fe, ie2) {
            if (ie2)
              G2(ie2);
            else
              try {
                b2._dbInfo.mStore.set(a2, fe), D2(E2);
              } catch (ce2) {
                G2(ce2);
              }
          });
        });
      });
      return N2(_2, v), _2;
    }
    var oe = true;
    p2._support = oe, p2._driver = g3, p2._initStorage = re, p2.clear = h2, p2.dropInstance = R2, p2.getItem = I2, p2.iterate = B, p2.key = H2, p2.keys = j2, p2.length = J, p2.removeItem = $2, p2.setItem = ee2, Object.defineProperty(p2, "__esModule", { value: true });
  });
});
var pe2 = Ze2(ke2());
var Be2 = Ze2(rr());
var ft2 = { display: "none", position: "fixed", top: "0", right: "0", width: "100%", height: "100%", borderRadius: "0", border: "none", zIndex: "2147483647" };
function ut2(p2) {
  for (let [g3, O2] of Object.entries(ft2))
    p2.style[g3] = O2;
}
function st2(p2) {
  let g3 = [].slice.call(document.querySelectorAll(".magic-iframe"));
  return Boolean(g3.find((O2) => O2.src.includes(p2)));
}
var Te2 = class extends gt {
  constructor() {
    super(...arguments);
    this.activeElement = null;
  }
  init() {
    this.test = "hello", this.iframe = new Promise((g3) => {
      let O2 = () => {
        if (st2(encodeURIComponent(this.parameters)))
          lr().log();
        else {
          let L2 = document.createElement("iframe");
          L2.classList.add("magic-iframe"), L2.dataset.magicIframeLabel = Ie(this.endpoint).host, L2.title = "Secure Modal", L2.src = Ie(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href, ut2(L2), document.body.appendChild(L2), g3(L2);
        }
      };
      ["loaded", "interactive", "complete"].includes(document.readyState) ? O2() : window.addEventListener("load", O2, false);
    }), window.addEventListener("message", (g3) => {
      var O2;
      if (g3.origin === this.endpoint && g3.data && g3.data.msgType && this.messageHandlers.size) {
        g3.data.response = (O2 = g3.data.response) != null ? O2 : {};
        for (let L2 of this.messageHandlers.values())
          L2(g3);
      }
    });
  }
  showOverlay() {
    return se2(this, null, function* () {
      let g3 = yield this.iframe;
      g3.style.display = "block", this.activeElement = document.activeElement, g3.focus();
    });
  }
  hideOverlay() {
    return se2(this, null, function* () {
      var O2;
      let g3 = yield this.iframe;
      g3.style.display = "none", ((O2 = this.activeElement) == null ? void 0 : O2.focus) && this.activeElement.focus(), this.activeElement = null;
    });
  }
  _post(g3) {
    return se2(this, null, function* () {
      let O2 = yield this.iframe;
      if (O2 && O2.contentWindow)
        O2.contentWindow.postMessage(g3, this.endpoint);
      else
        throw cr();
    });
  }
};
var _t2 = Tn($e, { platform: "web", sdkName: "magic-sdk", version: "8.1.1", defaultEndpoint: "https://auth.magic.link/", ViewController: Te2, configureStorage: () => se2(void 0, null, function* () {
  let p2 = pe2.default.createInstance({ name: "MagicAuthLocalStorageDB", storeName: "MagicAuthLocalStorage" });
  return yield p2.defineDriver(Be2), yield p2.setDriver([pe2.default.INDEXEDDB, pe2.default.LOCALSTORAGE, Be2._driver]), p2;
}) });
export {
  l as EthChainType,
  S as Extension,
  X as ExtensionError,
  se as ExtensionWarning,
  _t2 as Magic,
  u as MagicIncomingWindowMessage,
  g as MagicOutgoingWindowMessage,
  o as MagicPayloadMethod,
  w as RPCError,
  p as RPCErrorCode,
  b as SDKError,
  a as SDKErrorCode,
  W as SDKWarning,
  m as SDKWarningCode,
  it as isPromiEvent
};
//# sourceMappingURL=es-IEPQQHGC.js.map
