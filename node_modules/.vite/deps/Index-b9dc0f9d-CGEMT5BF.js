"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  $format,
  BN_PROTECT_RPC_URL,
  HtmlTag,
  Modal,
  SuccessStatusIcon,
  SvelteComponent,
  WalletAppBadge,
  add_flush_callback,
  add_render_callback,
  append,
  append_styles,
  attr,
  bind,
  binding_callbacks,
  bubble,
  chainIdToLabel,
  check_outros,
  component_subscribe,
  configuration,
  connect$1,
  connectWallet$,
  connectedToValidAppChain,
  copyWalletAddress,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  destroy_block,
  destroy_component,
  destroy_each,
  detach,
  disconnect,
  element,
  empty,
  en,
  fade,
  fly,
  getDefaultChainStyles,
  group_outros,
  handle_promise,
  init$1,
  insert,
  isSVG,
  is_function,
  listen,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  outro_and_destroy_block,
  poweredByBlocknative,
  quartOut,
  questionIcon,
  require_eventemitter3,
  require_lodash,
  require_lodash2,
  run_all,
  safe_not_equal,
  selectAccounts,
  select_option,
  setChain,
  setPrimaryWallet,
  set_data,
  set_style,
  shortenAddress,
  shortenDomain,
  space,
  src_url_equal,
  state$1,
  stop_propagation,
  text,
  toggle_class,
  transition_in,
  transition_out,
  unrecognizedChainStyle,
  updateAccountCenter,
  updateChainRPC,
  update_await_block_branch,
  update_keyed_each,
  wallets$
} from "./chunk-UNEH3MFK.js";
import "./chunk-HOMLBPTB.js";
import "./chunk-ML6D6LE5.js";
import "./chunk-Q7S4VSTZ.js";
import {
  merge
} from "./chunk-BM7TVH7W.js";
import {
  BehaviorSubject,
  debounceTime,
  distinctUntilChanged,
  shareReplay,
  skip,
  startWith
} from "./chunk-ULQNXVIW.js";
import "./chunk-JFI3VZJW.js";
import "./chunk-OKA6LQBG.js";
import "./chunk-ICXUKEMA.js";
import {
  ProviderRpcErrorCode
} from "./chunk-LYQEC7EU.js";
import {
  require_joi_browser_min
} from "./chunk-QDIGJPMI.js";
import {
  __toESM,
  require_dist
} from "./chunk-VJXJXNP7.js";

// node_modules/@web3-onboard/core/dist/Index-b9dc0f9d.js
var import_dist = __toESM(require_dist(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var import_joi = __toESM(require_joi_browser_min(), 1);
var import_lodash2 = __toESM(require_lodash2(), 1);
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var caretIcon = `<svg width="100%" height="24" viewBox="0 5 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 10L12 15L17 10H7Z" fill="currentColor"/></svg>`;
var warningIcon = `
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M1 21H23L12 2L1 21ZM13 18H11V16H13V18ZM13 14H11V10H13V14Z" fill="currentColor"/>
  </svg>
`;
function add_css$8(target) {
  append_styles(target, "svelte-1uqued6", "select.svelte-1uqued6{border:none;background-image:none;background-color:transparent;-webkit-appearance:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;appearance:none;font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));transition:width 250ms ease-in-out;background-repeat:no-repeat, repeat;background-position:right 0px top 0px, 0 0;scrollbar-width:none;-ms-overflow-style:none;padding:0 14px 0 0;white-space:nowrap;text-overflow:ellipsis}select.minimized_ac.svelte-1uqued6{min-width:80px;max-width:80px}select.maximized_ac.svelte-1uqued6{width:auto !important}select.svelte-1uqued6:focus{outline:none}span.switching-placeholder.svelte-1uqued6{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));min-width:80px;max-width:80px;padding:0 8px 0 4px}");
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_if_block$5(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$switching$*/
      ctx2[7]
    )
      return create_if_block_1$4;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$2(ctx) {
  let select;
  let show_if = !connectedToValidAppChain(
    /*wallet*/
    ctx[6].chains[0],
    /*chains*/
    ctx[2]
  );
  let if_block_anchor;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let select_class_value;
  let select_value_value;
  let select_style_value;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_2$4(ctx);
  let each_value = (
    /*chains*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*chain*/
    ctx2[15].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      select = element("select");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "class", select_class_value = null_to_empty(`flex justify-center items-center pointer ${/*parentCSSId*/
      ctx[4]}`) + " svelte-1uqued6");
      attr(select, "style", select_style_value = `
        color: var(${/*colorVar*/
      ctx[1]},
        var(--account-center-network-selector-color, var(--gray-500)));
        background-image: url('data:image/svg+xml;utf8,${/*selectIcon*/
      ctx[0]}'); ${/*bold*/
      ctx[3] ? "font-weight: 600;" : ""}`);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block)
        if_block.m(select, null);
      append(select, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*wallet*/
        ctx[6].chains[0].id
      );
      ctx[13](select);
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*handleSelect*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*wallet, chains*/
      68)
        show_if = !connectedToValidAppChain(
          /*wallet*/
          ctx2[6].chains[0],
          /*chains*/
          ctx2[2]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          if_block.m(select, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*chains, chainIdToLabel*/
      4) {
        each_value = /*chains*/
        ctx2[2];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$3, null, get_each_context$3);
      }
      if (dirty & /*parentCSSId*/
      16 && select_class_value !== (select_class_value = null_to_empty(`flex justify-center items-center pointer ${/*parentCSSId*/
      ctx2[4]}`) + " svelte-1uqued6")) {
        attr(select, "class", select_class_value);
      }
      if (dirty & /*wallet*/
      64 && select_value_value !== (select_value_value = /*wallet*/
      ctx2[6].chains[0].id)) {
        select_option(
          select,
          /*wallet*/
          ctx2[6].chains[0].id
        );
      }
      if (dirty & /*colorVar, selectIcon, bold*/
      11 && select_style_value !== (select_style_value = `
        color: var(${/*colorVar*/
      ctx2[1]},
        var(--account-center-network-selector-color, var(--gray-500)));
        background-image: url('data:image/svg+xml;utf8,${/*selectIcon*/
      ctx2[0]}'); ${/*bold*/
      ctx2[3] ? "font-weight: 600;" : ""}`)) {
        attr(select, "style", select_style_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let t;
  let span_class_value;
  let span_style_value;
  return {
    c() {
      span = element("span");
      t = text("switching...");
      attr(span, "class", span_class_value = null_to_empty(`switching-placeholder ${/*parentCSSId*/
      ctx[4]}`) + " svelte-1uqued6");
      attr(span, "style", span_style_value = `
        color: var(${/*colorVar*/
      ctx[1]},
        var(--account-center-network-selector-color, var(--gray-500)));
      `);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*parentCSSId*/
      16 && span_class_value !== (span_class_value = null_to_empty(`switching-placeholder ${/*parentCSSId*/
      ctx2[4]}`) + " svelte-1uqued6")) {
        attr(span, "class", span_class_value);
      }
      if (dirty & /*colorVar*/
      2 && span_style_value !== (span_style_value = `
        color: var(${/*colorVar*/
      ctx2[1]},
        var(--account-center-network-selector-color, var(--gray-500)));
      `)) {
        attr(span, "style", span_style_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$4(ctx) {
  let option;
  let t_value = (chainIdToLabel[
    /*wallet*/
    ctx[6].chains[0].id
  ] || "unrecognized") + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*wallet*/
      ctx[6].chains[0].id;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*wallet*/
      64 && t_value !== (t_value = (chainIdToLabel[
        /*wallet*/
        ctx2[6].chains[0].id
      ] || "unrecognized") + ""))
        set_data(t, t_value);
      if (dirty & /*wallet*/
      64 && option_value_value !== (option_value_value = /*wallet*/
      ctx2[6].chains[0].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block$3(key_1, ctx) {
  let option;
  let t_value = (
    /*chain*/
    (ctx[15].label || chainIdToLabel[
      /*chain*/
      ctx[15].id
    ] || /*chain*/
    ctx[15].id) + ""
  );
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*chain*/
      ctx[15].id;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*chains*/
      4 && t_value !== (t_value = /*chain*/
      (ctx[15].label || chainIdToLabel[
        /*chain*/
        ctx[15].id
      ] || /*chain*/
      ctx[15].id) + ""))
        set_data(t, t_value);
      if (dirty & /*chains*/
      4 && option_value_value !== (option_value_value = /*chain*/
      ctx[15].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$8(ctx) {
  let if_block_anchor;
  let if_block = (
    /*wallet*/
    ctx[6] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*wallet*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let wallet;
  let $resize$;
  let $wallets$;
  let $switching$;
  component_subscribe($$self, wallets$, ($$value) => $$invalidate(12, $wallets$ = $$value));
  let { selectIcon = caretIcon } = $$props;
  let { colorVar } = $$props;
  let { chains } = $$props;
  let { bold = false } = $$props;
  let { parentCSSId = "" } = $$props;
  const switching$ = new BehaviorSubject(false);
  component_subscribe($$self, switching$, (value) => $$invalidate(7, $switching$ = value));
  let selectElement;
  const resize$ = merge(wallets$, switching$.pipe(skip(1))).pipe(debounceTime(50), distinctUntilChanged((prev, next) => typeof prev === "boolean" || typeof next === "boolean" ? false : prev[0] && next[0] && prev[0].chains[0].id === next[0].chains[0].id));
  component_subscribe($$self, resize$, (value) => $$invalidate(11, $resize$ = value));
  async function handleSelect() {
    const selectedChain = selectElement.selectedOptions[0].value;
    if (selectedChain !== wallet.chains[0].id) {
      switching$.next(true);
      await setChain({
        chainId: selectedChain,
        chainNamespace: "evm",
        wallet: wallet.label
      });
      switching$.next(false);
    }
  }
  function resizeSelect() {
    if (!selectElement)
      return;
    let tempOption = document.createElement("option");
    tempOption.textContent = selectElement.selectedOptions[0].textContent;
    let tempSelect = document.createElement("select");
    tempSelect.style.visibility = "hidden";
    tempSelect.style.position = "fixed";
    tempSelect.appendChild(tempOption);
    selectElement.after(tempSelect);
    $$invalidate(5, selectElement.style.width = `${tempSelect.clientWidth - 22}px`, selectElement);
    tempSelect.remove();
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectElement = $$value;
      $$invalidate(5, selectElement);
      $$invalidate(2, chains);
      $$invalidate(6, wallet), $$invalidate(12, $wallets$);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("selectIcon" in $$props2)
      $$invalidate(0, selectIcon = $$props2.selectIcon);
    if ("colorVar" in $$props2)
      $$invalidate(1, colorVar = $$props2.colorVar);
    if ("chains" in $$props2)
      $$invalidate(2, chains = $$props2.chains);
    if ("bold" in $$props2)
      $$invalidate(3, bold = $$props2.bold);
    if ("parentCSSId" in $$props2)
      $$invalidate(4, parentCSSId = $$props2.parentCSSId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wallets$*/
    4096) {
      $$invalidate(6, [wallet] = $wallets$, wallet);
    }
    if ($$self.$$.dirty & /*$resize$*/
    2048) {
      if ($resize$) {
        resizeSelect();
      }
    }
  };
  return [
    selectIcon,
    colorVar,
    chains,
    bold,
    parentCSSId,
    selectElement,
    wallet,
    $switching$,
    switching$,
    resize$,
    handleSelect,
    $resize$,
    $wallets$,
    select_binding
  ];
}
var NetworkSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$8,
      create_fragment$8,
      safe_not_equal,
      {
        selectIcon: 0,
        colorVar: 1,
        chains: 2,
        bold: 3,
        parentCSSId: 4
      },
      add_css$8
    );
  }
};
var elipsisIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 8C13.1 8 14 7.1 14 6C14 4.9 13.1 4 12 4C10.9 4 10 4.9 10 6C10 7.1 10.9 8 12 8ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM12 16C10.9 16 10 16.9 10 18C10 19.1 10.9 20 12 20C13.1 20 14 19.1 14 18C14 16.9 13.1 16 12 16Z" fill="currentColor"/>
  </svg>
`;
function add_css$7(target) {
  append_styles(target, "svelte-hb2n95", ".container.svelte-hb2n95.svelte-hb2n95{display:flex;align-items:center;gap:0.5rem;cursor:pointer;position:relative;z-index:0;width:100%;padding:0.25rem;margin-bottom:0.25rem;border-radius:12px;transition:background-color 150ms ease-in-out}.container.svelte-hb2n95.svelte-hb2n95::before{content:'';display:block;position:absolute;top:0;bottom:0;left:0;right:0;height:100%;width:100%;background:var(--action-color);border-radius:12px;z-index:-1;opacity:0}.container.svelte-hb2n95.svelte-hb2n95:hover::before{opacity:0.2}.container.svelte-hb2n95:hover .balance.svelte-hb2n95,.container.svelte-hb2n95:hover .elipsis-container.svelte-hb2n95{opacity:1}.container.svelte-hb2n95:hover .balance.svelte-hb2n95{color:var(--account-center-maximized-balance-color, inherit)}.container.primary.svelte-hb2n95.svelte-hb2n95:hover{background-color:var(\n      --account-center-maximized-account-section-background-hover\n    )}.account-details.svelte-hb2n95.svelte-hb2n95{flex:1 1;display:flex;gap:inherit;overflow:hidden}.address-domain.svelte-hb2n95.svelte-hb2n95{flex:1 0 auto;max-width:70%;white-space:nowrap;font-weight:600;color:var(--account-center-maximized-address-color, inherit);overflow:scroll;scrollbar-width:none;-ms-overflow-style:none}.address-domain.svelte-hb2n95.svelte-hb2n95::-webkit-scrollbar{display:none}.balance.svelte-hb2n95.svelte-hb2n95{flex:1 1 auto;max-width:70%;white-space:nowrap;text-align:end;opacity:0.4;transition:color 150ms ease-in-out, background-color 150ms ease-in-out;overflow:scroll;scrollbar-width:none;-ms-overflow-style:none}.balance.svelte-hb2n95.svelte-hb2n95::-webkit-scrollbar{display:none}.elipsis-container.svelte-hb2n95.svelte-hb2n95{flex:0;padding:0.25rem;border-radius:24px;transition:color 150ms ease-in-out, background-color 150ms ease-in-out;background-color:transparent;opacity:0.4}.elipsis-container.svelte-hb2n95.svelte-hb2n95:hover{color:var(--text-color)}.elipsis-container.active.svelte-hb2n95.svelte-hb2n95{color:var(--text-color)}.elipsis.svelte-hb2n95.svelte-hb2n95{width:24px}.menu.svelte-hb2n95.svelte-hb2n95{background:var(--onboard-white, var(--white));border:1px solid var(--onboard-gray-100, var(--gray-100));border-radius:8px;list-style-type:none;right:0.25rem;top:2.25rem;margin:0;padding:0;border:none;overflow:hidden;z-index:1}.menu.svelte-hb2n95 li.svelte-hb2n95{color:var(--onboard-primary-500, var(--primary-500));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));padding:12px 16px;background:var(--onboard-white, var(--white));transition:background-color 150ms ease-in-out;cursor:pointer}.menu.svelte-hb2n95 li.svelte-hb2n95:hover{background:var(--onboard-primary-200, var(--primary-200))}");
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i].address;
  child_ctx[15] = list[i].ens;
  child_ctx[16] = list[i].uns;
  child_ctx[17] = list[i].balance;
  child_ctx[19] = i;
  return child_ctx;
}
function create_if_block_3$1(ctx) {
  let div;
  let successstatusicon;
  let current;
  successstatusicon = new SuccessStatusIcon({ props: { size: 14 } });
  return {
    c() {
      div = element("div");
      create_component(successstatusicon.$$.fragment);
      set_style(div, "right", "-5px");
      set_style(div, "bottom", "-5px");
      attr(div, "class", "drop-shadow absolute");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(successstatusicon, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(successstatusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(successstatusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(successstatusicon);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let t_value = formatBalance(
    /*balance*/
    ctx[17]
  ) + "";
  let t;
  let div_intro;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "balance svelte-hb2n95");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*wallet*/
      1 && t_value !== (t_value = formatBalance(
        /*balance*/
        ctx2[17]
      ) + ""))
        set_data(t, t_value);
    },
    i(local) {
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, fade, {});
            div_intro.start();
          });
        }
      }
    },
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$4(ctx) {
  let ul;
  let li0;
  let t0_value = (
    /*$_*/
    ctx[4]("accountCenter.addAccount", {
      default: (
        /*en*/
        ctx[2].accountCenter.addAccount
      )
    }) + ""
  );
  let t0;
  let t1;
  let t2;
  let li1;
  let t3_value = (
    /*$_*/
    ctx[4]("accountCenter.disconnectWallet", {
      default: (
        /*en*/
        ctx[2].accountCenter.disconnectWallet
      )
    }) + ""
  );
  let t3;
  let t4;
  let li2;
  let t5_value = (
    /*en*/
    ctx[2].accountCenter.copyAddress + ""
  );
  let t5;
  let ul_intro;
  let mounted;
  let dispose;
  let if_block = !/*primary*/
  (ctx[1] && /*i*/
  ctx[19] === 0) && create_if_block_1$3(ctx);
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[13](
        /*ens*/
        ctx[15],
        /*uns*/
        ctx[16],
        /*address*/
        ctx[14]
      )
    );
  }
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      li1 = element("li");
      t3 = text(t3_value);
      t4 = space();
      li2 = element("li");
      t5 = text(t5_value);
      attr(li0, "class", "svelte-hb2n95");
      attr(li1, "class", "svelte-hb2n95");
      attr(li2, "class", "svelte-hb2n95");
      attr(ul, "class", "menu absolute svelte-hb2n95");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      append(li0, t0);
      append(ul, t1);
      if (if_block)
        if_block.m(ul, null);
      append(ul, t2);
      append(ul, li1);
      append(li1, t3);
      append(ul, t4);
      append(ul, li2);
      append(li2, t5);
      if (!mounted) {
        dispose = [
          listen(li0, "click", stop_propagation(
            /*click_handler_2*/
            ctx[10]
          )),
          listen(li1, "click", stop_propagation(
            /*click_handler_4*/
            ctx[12]
          )),
          listen(li2, "click", stop_propagation(click_handler_5))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$_, en*/
      20 && t0_value !== (t0_value = /*$_*/
      ctx[4]("accountCenter.addAccount", {
        default: (
          /*en*/
          ctx[2].accountCenter.addAccount
        )
      }) + ""))
        set_data(t0, t0_value);
      if (!/*primary*/
      (ctx[1] && /*i*/
      ctx[19] === 0)) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$3(ctx);
          if_block.c();
          if_block.m(ul, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$_, en*/
      20 && t3_value !== (t3_value = /*$_*/
      ctx[4]("accountCenter.disconnectWallet", {
        default: (
          /*en*/
          ctx[2].accountCenter.disconnectWallet
        )
      }) + ""))
        set_data(t3, t3_value);
      if (dirty & /*en*/
      4 && t5_value !== (t5_value = /*en*/
      ctx[2].accountCenter.copyAddress + ""))
        set_data(t5, t5_value);
    },
    i(local) {
      if (local) {
        if (!ul_intro) {
          add_render_callback(() => {
            ul_intro = create_in_transition(ul, fade, {});
            ul_intro.start();
          });
        }
      }
    },
    o: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$3(ctx) {
  let li;
  let t_value = (
    /*$_*/
    ctx[4]("accountCenter.setPrimaryAccount", {
      default: (
        /*en*/
        ctx[2].accountCenter.setPrimaryAccount
      )
    }) + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[11](
        /*address*/
        ctx[14]
      )
    );
  }
  return {
    c() {
      li = element("li");
      t = text(t_value);
      attr(li, "class", "svelte-hb2n95");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
      if (!mounted) {
        dispose = listen(li, "click", stop_propagation(click_handler_3));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$_, en*/
      20 && t_value !== (t_value = /*$_*/
      ctx[4]("accountCenter.setPrimaryAccount", {
        default: (
          /*en*/
          ctx[2].accountCenter.setPrimaryAccount
        )
      }) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$2(ctx) {
  let div6;
  let div5;
  let div0;
  let walletappbadge;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2_value = (
    /*ens*/
    (ctx[15] ? shortenDomain(
      /*ens*/
      ctx[15].name
    ) : (
      /*uns*/
      ctx[16] ? shortenDomain(
        /*uns*/
        ctx[16].name
      ) : shortenAddress(
        /*address*/
        ctx[14]
      )
    )) + ""
  );
  let t2;
  let t3;
  let t4;
  let div4;
  let div3;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  walletappbadge = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "custom",
      color: "#EFF1FC",
      customBackgroundColor: (
        /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0 ? "rgba(24, 206, 102, 0.2)" : "rgba(235, 235, 237, 0.1)"
      ),
      border: (
        /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0 ? "green" : "gray"
      ),
      radius: 8,
      icon: (
        /*wallet*/
        ctx[0].icon
      )
    }
  });
  let if_block0 = (
    /*primary*/
    ctx[1] && /*i*/
    ctx[19] === 0 && create_if_block_3$1()
  );
  let if_block1 = (
    /*balance*/
    ctx[17] && create_if_block_2$3(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[8](
        /*address*/
        ctx[14]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[9](
        /*address*/
        ctx[14]
      )
    );
  }
  let if_block2 = (
    /*showMenu*/
    ctx[3] === /*address*/
    ctx[14] && create_if_block$4(ctx)
  );
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div0 = element("div");
      create_component(walletappbadge.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      div4 = element("div");
      div3 = element("div");
      t5 = space();
      if (if_block2)
        if_block2.c();
      t6 = space();
      attr(div0, "class", "flex items-center relative");
      attr(div1, "class", "address-domain svelte-hb2n95");
      attr(div2, "class", "account-details svelte-hb2n95");
      attr(div3, "class", "elipsis pointer flex items-center justify-center relative svelte-hb2n95");
      attr(div4, "class", "elipsis-container svelte-hb2n95");
      toggle_class(
        div4,
        "active",
        /*showMenu*/
        ctx[3] === /*address*/
        ctx[14]
      );
      attr(div5, "class", "container svelte-hb2n95");
      toggle_class(
        div5,
        "primary",
        /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0
      );
      attr(div6, "class", "relative");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div0);
      mount_component(walletappbadge, div0, null);
      append(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div5, t1);
      append(div5, div2);
      append(div2, div1);
      append(div1, t2);
      append(div2, t3);
      if (if_block1)
        if_block1.m(div2, null);
      append(div5, t4);
      append(div5, div4);
      append(div4, div3);
      div3.innerHTML = elipsisIcon;
      append(div6, t5);
      if (if_block2)
        if_block2.m(div6, null);
      append(div6, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div3, "click", stop_propagation(click_handler)),
          listen(div5, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const walletappbadge_changes = {};
      if (dirty & /*primary*/
      2)
        walletappbadge_changes.customBackgroundColor = /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0 ? "rgba(24, 206, 102, 0.2)" : "rgba(235, 235, 237, 0.1)";
      if (dirty & /*primary*/
      2)
        walletappbadge_changes.border = /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0 ? "green" : "gray";
      if (dirty & /*wallet*/
      1)
        walletappbadge_changes.icon = /*wallet*/
        ctx[0].icon;
      walletappbadge.$set(walletappbadge_changes);
      if (
        /*primary*/
        ctx[1] && /*i*/
        ctx[19] === 0
      ) {
        if (if_block0) {
          if (dirty & /*primary*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$1();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*wallet*/
      1) && t2_value !== (t2_value = /*ens*/
      (ctx[15] ? shortenDomain(
        /*ens*/
        ctx[15].name
      ) : (
        /*uns*/
        ctx[16] ? shortenDomain(
          /*uns*/
          ctx[16].name
        ) : shortenAddress(
          /*address*/
          ctx[14]
        )
      )) + ""))
        set_data(t2, t2_value);
      if (
        /*balance*/
        ctx[17]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*wallet*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$3(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*showMenu, wallet*/
      9) {
        toggle_class(
          div4,
          "active",
          /*showMenu*/
          ctx[3] === /*address*/
          ctx[14]
        );
      }
      if (!current || dirty & /*primary*/
      2) {
        toggle_class(
          div5,
          "primary",
          /*primary*/
          ctx[1] && /*i*/
          ctx[19] === 0
        );
      }
      if (
        /*showMenu*/
        ctx[3] === /*address*/
        ctx[14]
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & /*showMenu, wallet*/
          9) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$4(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div6, t6);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(walletappbadge);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$7(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*wallet*/
    ctx[0].accounts
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*copyWalletAddress, wallet, changeText, en, showMenu, disconnect, $_, setPrimaryWallet, primary, selectAnotherAccount, elipsisIcon, formatBalance, shortenDomain, shortenAddress*/
      127) {
        each_value = /*wallet*/
        ctx2[0].accounts;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function formatBalance(balance) {
  const [asset] = Object.keys(balance);
  return `${balance[asset].length > 7 ? balance[asset].slice(0, 7) : balance[asset]} ${asset}`;
}
function instance$7($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, $format, ($$value) => $$invalidate(4, $_ = $$value));
  let { wallet } = $$props;
  let { primary } = $$props;
  function hideMenu() {
    $$invalidate(3, showMenu = "");
  }
  let showMenu = "";
  async function selectAnotherAccount(wallet2) {
    try {
      await selectAccounts(wallet2.provider);
    } catch (error) {
      const { code } = error;
      if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD || code === ProviderRpcErrorCode.DOES_NOT_EXIST) {
        connectWallet$.next({
          inProgress: false,
          actionRequired: wallet2.label
        });
      }
    }
  }
  function changeText() {
    $$invalidate(2, en.accountCenter.copyAddress = "Copied Successfully", en);
    setTimeout(hideMenu, 500);
    setTimeout(
      () => {
        $$invalidate(2, en.accountCenter.copyAddress = "Copy Wallet address", en);
      },
      700
    );
  }
  const click_handler = (address) => $$invalidate(3, showMenu = showMenu === address ? "" : address);
  const click_handler_1 = (address) => setPrimaryWallet(wallet, address);
  const click_handler_2 = () => {
    $$invalidate(3, showMenu = "");
    selectAnotherAccount(wallet);
  };
  const click_handler_3 = (address) => {
    $$invalidate(3, showMenu = "");
    setPrimaryWallet(wallet, address);
  };
  const click_handler_4 = () => {
    $$invalidate(3, showMenu = "");
    disconnect({ label: wallet.label });
  };
  const click_handler_5 = (ens, uns, address) => {
    copyWalletAddress(ens ? ens.name : uns ? uns.name : address).then(() => {
      changeText();
    });
  };
  $$self.$$set = ($$props2) => {
    if ("wallet" in $$props2)
      $$invalidate(0, wallet = $$props2.wallet);
    if ("primary" in $$props2)
      $$invalidate(1, primary = $$props2.primary);
  };
  return [
    wallet,
    primary,
    en,
    showMenu,
    $_,
    selectAnotherAccount,
    changeText,
    hideMenu,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
var WalletRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { wallet: 0, primary: 1, hideMenu: 7 }, add_css$7);
  }
  get hideMenu() {
    return this.$$.ctx[7];
  }
};
var plusCircleIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M13 7H11V11H7V13H11V17H13V13H17V11H13V7ZM12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20Z" fill="currentColor"/>
  </svg>
`;
var arrowForwardIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M10.09 15.59L11.5 17L16.5 12L11.5 7L10.09 8.41L12.67 11H3V13H12.67L10.09 15.59ZM19 3H5C3.89 3 3 3.9 3 5V9H5V5H19V19H5V15H3V19C3 20.1 3.89 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z" fill="currentColor"/>
  </svg>
`;
var caretLightIcon = `<svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.59 8.59L12 13.17L7.41 8.59L6 10L12 16L18 10L16.59 8.59Z" fill="currentColor"/></svg>`;
var shieldIcon = `<svg width="14" height="18" viewBox="0 0 14 18" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.99998 17.3125C5.05553 16.8264 3.45831 15.6979 2.20831 13.9271C0.958313 12.1562 0.333313 10.2153 0.333313 8.10417V3.14583L6.99998 0.645833L13.6666 3.14583V8.10417C13.6666 10.2153 13.0416 12.1562 11.7916 13.9271C10.5416 15.6979 8.94442 16.8264 6.99998 17.3125ZM5.12498 12.3333H8.87498C9.05553 12.3333 9.20484 12.2743 9.3229 12.1562C9.44095 12.0382 9.49998 11.8889 9.49998 11.7083V8.79167C9.49998 8.61111 9.44095 8.46181 9.3229 8.34375C9.20484 8.22569 9.05553 8.16667 8.87498 8.16667H8.66665V7.33333C8.66665 6.875 8.50345 6.48264 8.17706 6.15625C7.85067 5.82986 7.45831 5.66667 6.99998 5.66667C6.54165 5.66667 6.14928 5.82986 5.8229 6.15625C5.49651 6.48264 5.33331 6.875 5.33331 7.33333V8.16667H5.12498C4.94442 8.16667 4.79512 8.22569 4.67706 8.34375C4.55901 8.46181 4.49998 8.61111 4.49998 8.79167V11.7083C4.49998 11.8889 4.55901 12.0382 4.67706 12.1562C4.79512 12.2743 4.94442 12.3333 5.12498 12.3333ZM5.95831 8.16667V7.33333C5.95831 7.05556 6.06248 6.82292 6.27081 6.63542C6.47915 6.44792 6.7222 6.35417 6.99998 6.35417C7.27776 6.35417 7.52081 6.44792 7.72915 6.63542C7.93748 6.82292 8.04165 7.05556 8.04165 7.33333V8.16667H5.95831Z" fill="#929BED"/>
</svg>
`;
function add_css$6(target) {
  append_styles(target, "svelte-1ubxcdp", ".content.svelte-1ubxcdp{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px}.icon-container.svelte-1ubxcdp{width:3rem;height:3rem;background:var(--onboard-warning-100, var(--warning-100));border-radius:24px;padding:12px;color:var(--onboard-warning-500, var(--warning-500))}h4.svelte-1ubxcdp{margin:1.5rem 0 0.5rem 0;font-weight:600}p.svelte-1ubxcdp{margin:0;font-weight:400}button.svelte-1ubxcdp{margin-top:1.5rem;width:50%;font-weight:600}.right.svelte-1ubxcdp{margin-left:0.5rem;width:60%}");
}
function create_default_slot$1(ctx) {
  let div2;
  let div0;
  let t0;
  let h4;
  let t1_value = (
    /*$_*/
    ctx[2]("modals.confirmDisconnectAll.heading", {
      default: en.modals.confirmDisconnectAll.heading
    }) + ""
  );
  let t1;
  let t2;
  let p;
  let t3_value = (
    /*$_*/
    ctx[2]("modals.confirmDisconnectAll.description") + ""
  );
  let t3;
  let t4;
  let div1;
  let button0;
  let t5_value = (
    /*$_*/
    ctx[2]("modals.confirmDisconnectAll.cancel", {
      default: en.modals.confirmDisconnectAll.cancel
    }) + ""
  );
  let t5;
  let t6;
  let button1;
  let t7_value = (
    /*$_*/
    ctx[2]("modals.confirmDisconnectAll.confirm", {
      default: en.modals.confirmDisconnectAll.confirm
    }) + ""
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      p = element("p");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      button0 = element("button");
      t5 = text(t5_value);
      t6 = space();
      button1 = element("button");
      t7 = text(t7_value);
      attr(div0, "class", "icon-container flex justify-center items-center svelte-1ubxcdp");
      attr(h4, "class", "svelte-1ubxcdp");
      attr(p, "class", "svelte-1ubxcdp");
      attr(button0, "class", "button-neutral-solid-b rounded svelte-1ubxcdp");
      attr(button1, "class", "right button-neutral-solid rounded svelte-1ubxcdp");
      attr(div1, "class", "flex justify-between items-center w-100");
      attr(div2, "class", "content svelte-1ubxcdp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      div0.innerHTML = warningIcon;
      append(div2, t0);
      append(div2, h4);
      append(h4, t1);
      append(div2, t2);
      append(div2, p);
      append(p, t3);
      append(div2, t4);
      append(div2, div1);
      append(div1, button0);
      append(button0, t5);
      append(div1, t6);
      append(div1, button1);
      append(button1, t7);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*onConfirm*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$_*/
      4 && t1_value !== (t1_value = /*$_*/
      ctx[2]("modals.confirmDisconnectAll.heading", {
        default: en.modals.confirmDisconnectAll.heading
      }) + ""))
        set_data(t1, t1_value);
      if (dirty & /*$_*/
      4 && t3_value !== (t3_value = /*$_*/
      ctx[2]("modals.confirmDisconnectAll.description") + ""))
        set_data(t3, t3_value);
      if (dirty & /*$_*/
      4 && t5_value !== (t5_value = /*$_*/
      ctx[2]("modals.confirmDisconnectAll.cancel", {
        default: en.modals.confirmDisconnectAll.cancel
      }) + ""))
        set_data(t5, t5_value);
      if (dirty & /*$_*/
      4 && t7_value !== (t7_value = /*$_*/
      ctx[2]("modals.confirmDisconnectAll.confirm", {
        default: en.modals.confirmDisconnectAll.confirm
      }) + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$6(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: (
        /*onClose*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & /*onClose*/
      2)
        modal_changes.close = /*onClose*/
        ctx2[1];
      if (dirty & /*$$scope, onConfirm, $_, onClose*/
      15) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, $format, ($$value) => $$invalidate(2, $_ = $$value));
  let { onConfirm } = $$props;
  let { onClose } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onConfirm" in $$props2)
      $$invalidate(0, onConfirm = $$props2.onConfirm);
    if ("onClose" in $$props2)
      $$invalidate(1, onClose = $$props2.onClose);
  };
  return [onConfirm, onClose, $_];
}
var DisconnectAllConfirm = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { onConfirm: 0, onClose: 1 }, add_css$6);
  }
};
function add_css$5(target) {
  append_styles(target, "svelte-1ukfiqz", ".content.svelte-1ukfiqz{--background-color:var(--w3o-background-color);--text-color:var(--w3o-text-color);--action-color:var(--w3o-action-color, var(--primary-500));font-size:1rem;line-height:1.5rem;display:flex;flex-flow:column;gap:1.5rem;padding:1rem;max-width:320px;background:var(--background-color);color:var(--text-color)}.icon-container.svelte-1ukfiqz{position:relative;overflow:hidden;width:3rem;height:3rem;border-radius:24px;padding:.75rem;background:none}.icon-container.svelte-1ukfiqz::before{content:'';position:absolute;height:100%;width:100%;opacity:0.2;background:var(--action-color)}.text-container.svelte-1ukfiqz{display:flex;flex-flow:column;gap:0.5rem;padding:0 0.5rem}.actions-container.svelte-1ukfiqz{display:flex;flex-flow:row nowrap;gap:1rem}.heading.svelte-1ukfiqz{font-weight:600}button.svelte-1ukfiqz{font-weight:600}button.primary.svelte-1ukfiqz{background:var(--action-color)}");
}
function create_default_slot(ctx) {
  let div5;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1_value = (
    /*$_*/
    ctx[2]("modals.confirmTransactionProtection.heading", {
      default: en.modals.confirmTransactionProtection.heading
    }) + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*$_*/
    ctx[2]("modals.confirmTransactionProtection.description") + ""
  );
  let t3;
  let t4;
  let div4;
  let button0;
  let t5_value = (
    /*$_*/
    ctx[2]("modals.confirmTransactionProtection.dismiss", {
      default: en.modals.confirmTransactionProtection.dismiss
    }) + ""
  );
  let t5;
  let t6;
  let button1;
  let t7_value = (
    /*$_*/
    ctx[2]("modals.confirmTransactionProtection.enable", {
      default: en.modals.confirmTransactionProtection.enable
    }) + ""
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div4 = element("div");
      button0 = element("button");
      t5 = text(t5_value);
      t6 = space();
      button1 = element("button");
      t7 = text(t7_value);
      attr(div0, "class", "icon-container flex justify-center items-center svelte-1ukfiqz");
      attr(div1, "class", "heading svelte-1ukfiqz");
      attr(div3, "class", "text-container svelte-1ukfiqz");
      attr(button0, "class", "button-neutral-solid-b svelte-1ukfiqz");
      attr(button1, "class", "button-neutral-solid rounded primary svelte-1ukfiqz");
      attr(div4, "class", "actions-container svelte-1ukfiqz");
      attr(div5, "class", "content svelte-1ukfiqz");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      div0.innerHTML = shieldIcon;
      append(div5, t0);
      append(div5, div3);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      append(div5, t4);
      append(div5, div4);
      append(div4, button0);
      append(button0, t5);
      append(div4, t6);
      append(div4, button1);
      append(button1, t7);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*onDismiss*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*onEnable*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$_*/
      4 && t1_value !== (t1_value = /*$_*/
      ctx[2]("modals.confirmTransactionProtection.heading", {
        default: en.modals.confirmTransactionProtection.heading
      }) + ""))
        set_data(t1, t1_value);
      if (dirty & /*$_*/
      4 && t3_value !== (t3_value = /*$_*/
      ctx[2]("modals.confirmTransactionProtection.description") + ""))
        set_data(t3, t3_value);
      if (dirty & /*$_*/
      4 && t5_value !== (t5_value = /*$_*/
      ctx[2]("modals.confirmTransactionProtection.dismiss", {
        default: en.modals.confirmTransactionProtection.dismiss
      }) + ""))
        set_data(t5, t5_value);
      if (dirty & /*$_*/
      4 && t7_value !== (t7_value = /*$_*/
      ctx[2]("modals.confirmTransactionProtection.enable", {
        default: en.modals.confirmTransactionProtection.enable
      }) + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: (
        /*onDismiss*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & /*onDismiss*/
      2)
        modal_changes.close = /*onDismiss*/
        ctx2[1];
      if (dirty & /*$$scope, onEnable, $_, onDismiss*/
      15) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, $format, ($$value) => $$invalidate(2, $_ = $$value));
  let { onEnable } = $$props;
  let { onDismiss } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onEnable" in $$props2)
      $$invalidate(0, onEnable = $$props2.onEnable);
    if ("onDismiss" in $$props2)
      $$invalidate(1, onDismiss = $$props2.onDismiss);
  };
  return [onEnable, onDismiss, $_];
}
var EnableTransactionProtection = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { onEnable: 0, onDismiss: 1 }, add_css$5);
  }
};
function add_css$4(target) {
  append_styles(target, "svelte-b848yl", ".secondary-token-container.svelte-b848yl.svelte-b848yl{width:100%}table.svelte-b848yl.svelte-b848yl{width:100%}tr.svelte-b848yl.svelte-b848yl{padding:0.25rem 1rem;line-height:1rem;border-bottom:1px solid var(--border-color);display:flex;flex-direction:row;align-items:flex-start;gap:1rem}thead.svelte-b848yl .secondary-token-table-header.svelte-b848yl{text-align:inherit;font-size:var(--onboard-font-size-7, var(--font-size-7))}.token-icon.svelte-b848yl.svelte-b848yl{width:30%;font-weight:700;font-size:var(--onboard-font-size-6, var(--font-size-6));color:var(--text-color)}.icon-name-container.svelte-b848yl.svelte-b848yl{display:flex;flex-direction:row;align-items:flex-start;padding:0px;gap:0.5rem}.icon.svelte-b848yl.svelte-b848yl{width:1rem;height:1rem}img.svelte-b848yl.svelte-b848yl{height:100%;width:100%}.token-balance.svelte-b848yl.svelte-b848yl{width:70%;font-weight:200;font-size:var(--onboard-font-size-6, var(--font-size-6));color:var(--text-color)}");
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
}
function create_if_block$3(ctx) {
  let tr;
  let td0;
  let div;
  let t0;
  let t1_value = (
    /*token*/
    ctx[1].name.toUpperCase() + ""
  );
  let t1;
  let t2;
  let td1;
  let t3_value = (
    /*token*/
    (ctx[1].balance.length > 7 ? (
      /*token*/
      ctx[1].balance.slice(0, 7)
    ) : (
      /*token*/
      ctx[1].balance
    )) + ""
  );
  let t3;
  let t4;
  function select_block_type(ctx2, dirty) {
    if (
      /*token*/
      ctx2[1].icon
    )
      return create_if_block_1$2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div = element("div");
      if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      td1 = element("td");
      t3 = text(t3_value);
      t4 = space();
      attr(div, "class", "icon-name-container svelte-b848yl");
      attr(td0, "class", "token-icon svelte-b848yl");
      attr(td1, "class", "token-balance svelte-b848yl");
      attr(tr, "class", "token-row svelte-b848yl");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div);
      if_block.m(div, null);
      append(div, t0);
      append(div, t1);
      append(tr, t2);
      append(tr, td1);
      append(td1, t3);
      append(tr, t4);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, t0);
        }
      }
      if (dirty & /*secondaryTokens*/
      1 && t1_value !== (t1_value = /*token*/
      ctx2[1].name.toUpperCase() + ""))
        set_data(t1, t1_value);
      if (dirty & /*secondaryTokens*/
      1 && t3_value !== (t3_value = /*token*/
      (ctx2[1].balance.length > 7 ? (
        /*token*/
        ctx2[1].balance.slice(0, 7)
      ) : (
        /*token*/
        ctx2[1].balance
      )) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "icon svelte-b848yl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$2(ctx) {
  let await_block_anchor;
  let promise;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 4
  };
  handle_promise(promise = /*token*/
  ctx[1].icon, info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*secondaryTokens*/
      1 && promise !== (promise = /*token*/
      ctx[1].icon) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let div;
  let show_if;
  let div_intro;
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*secondaryTokens*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!isSVG(
        /*iconLoaded*/
        ctx2[4]
      );
    if (show_if)
      return create_if_block_2$2;
    return create_else_block$1;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "icon svelte-b848yl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i(local) {
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, fade, {});
            div_intro.start();
          });
        }
      }
    },
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block$1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*iconLoaded*/
      ctx[4]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "logo");
      attr(img, "class", "svelte-b848yl");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*secondaryTokens*/
      1 && !src_url_equal(img.src, img_src_value = /*iconLoaded*/
      ctx2[4])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_2$2(ctx) {
  let html_tag;
  let raw_value = (
    /*iconLoaded*/
    ctx[4] + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*secondaryTokens*/
      1 && raw_value !== (raw_value = /*iconLoaded*/
      ctx2[4] + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_pending_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_each_block$1(ctx) {
  let if_block_anchor;
  let if_block = (
    /*token*/
    ctx[1] && /*token*/
    ctx[1].name && /*token*/
    ctx[1].balance && create_if_block$3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*token*/
        ctx2[1] && /*token*/
        ctx2[1].name && /*token*/
        ctx2[1].balance
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$4(ctx) {
  let div;
  let table;
  let thead;
  let t1;
  let tbody;
  let each_value = (
    /*secondaryTokens*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="svelte-b848yl"><th colspan="3" class="secondary-token-table-header svelte-b848yl">Token Balances:</th></tr>`;
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(thead, "class", "svelte-b848yl");
      attr(table, "class", "balance-change-table table-radius svelte-b848yl");
      attr(div, "class", "secondary-token-container svelte-b848yl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, table);
      append(table, thead);
      append(table, t1);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*secondaryTokens, isSVG*/
      1) {
        each_value = /*secondaryTokens*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { secondaryTokens } = $$props;
  $$self.$$set = ($$props2) => {
    if ("secondaryTokens" in $$props2)
      $$invalidate(0, secondaryTokens = $$props2.secondaryTokens);
  };
  return [secondaryTokens];
}
var SecondaryTokenTable = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { secondaryTokens: 0 }, add_css$4);
  }
};
function add_css$3(target) {
  append_styles(target, "svelte-177u10y", ".outer-container.svelte-177u10y{--background-color:var(--w3o-background-color);--text-color:var(--w3o-text-color);--border-color:var(--w3o-border-color, var(--gray-500));--action-color:var(--w3o-action-color, var(--primary-500));--border-radius:var(--w3o-border-radius, 1rem);--account-center-network-selector-color:var(--text-color, white);width:100%;overflow:hidden;pointer-events:auto;border:1px solid transparent;background:var(\n      --account-center-maximized-upper-background,\n      var(--background-color)\n    );border-color:var(--border-color);border-radius:var(--account-center-border-radius, var(--border-radius))}.wallets-section.svelte-177u10y{width:100%;color:var(--text-color, var(--gray-100));background:var(--background-color, var(--gray-700))}.p5.svelte-177u10y{padding:var(--onboard-spacing-5, var(--spacing-5))}.wallets.svelte-177u10y{width:100%;margin-bottom:0.5rem}.actions.svelte-177u10y{color:var(\n      --account-center-maximized-upper-action-color,\n      var(--action-color)\n    );padding-left:2px}.action-container.svelte-177u10y{padding:0.25rem 12px 0.25rem 0.5rem;border-radius:0.5rem;transition:background-color 150ms ease-in-out}.action-container.svelte-177u10y:hover{background-color:var(\n      --account-center-maximized-upper-action-background-hover,\n      rgba(146, 155, 237, 0.2)\n    )}.plus-icon.svelte-177u10y{width:20px}.arrow-forward.svelte-177u10y{width:20px}.mt.svelte-177u10y{margin-top:0.25rem}.action-text.svelte-177u10y{font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));margin-left:0.5rem}.background-blue.svelte-177u10y{background:var(\n      --account-center-maximized-network-section-background,\n      var(--onboard-primary-100, var(--primary-100))\n    )}.background-gray.svelte-177u10y{background:var(--onboard-gray-100, var(--gray-100))}.background-yellow.svelte-177u10y{background:var(--onboard-warning-100, var(--warning-100))}.network-container.svelte-177u10y{background:var(--background-color);border-top:1px solid var(--border-color);width:100%;display:flex;flex-direction:column;align-items:flex-start;padding:0.75rem;gap:0.5rem;border-radius:var(\n      --account-center-border-radius,\n      var(--onboard-border-radius-3, var(--border-radius-3))\n    );color:var(\n      --account-center-maximized-network-text-color,\n      var(--account-center-maximized-network-section, inherit)\n    )}.network-section.svelte-177u10y{flex-direction:row;align-items:flex-start;padding:0px;gap:16px}.network-selector-container.svelte-177u10y{width:100%}.protect.svelte-177u10y{flex-direction:row;padding:0.25rem 0.375rem 0;gap:0.375rem;width:100%}.shield.svelte-177u10y{width:20px;height:20px;display:flex;justify-content:center}.protect-text.svelte-177u10y{font-size:var(--onboard-font-size-6, var(--font-size-6));color:var(\n      --account-center-maximized-upper-action-color,\n      var(--action-color)\n    );line-height:1.75rem;display:flex;align-items:center}.network-selector-container.svelte-177u10y{margin-left:1rem;width:100%}.network-selector-label.svelte-177u10y{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}.app-info-container.svelte-177u10y{color:var(--text-color, var(--gray-700));background:var(\n      --account-center-maximized-info-section-background-color,\n      var(\n        --account-center-maximized-info-section,\n        var(--background-color, #fff)\n      )\n    );border-top:1px solid var(--border-color);border-radius:var(--account-center-border-radius, inherit);display:flex;flex-direction:column;align-items:flex-start;padding:0px}.app-info-header.svelte-177u10y{width:100%;flex-direction:column;align-items:flex-start;padding:0.75rem;gap:0.5rem;border-bottom:1px solid var(--border-color)}.app-icon-name.svelte-177u10y{display:flex;align-items:center;flex-direction:row;gap:0.75rem}.app-name.svelte-177u10y{font-size:1rem;font-weight:600;line-height:1rem;margin-bottom:0.25rem;color:var(--account-center-maximized-app-name-color, inherit)}.app-description.svelte-177u10y{margin:0;font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));color:var(--account-center-maximized-app-info-color, inherit);display:flex;flex-direction:row;align-items:flex-start;padding:0px 0.25rem;gap:1rem}.app-info.svelte-177u10y{width:100%;font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));color:var(--account-center-maximized-app-info-color, inherit);border-bottom:1px solid var(--border-color);display:flex;flex-direction:column;align-items:flex-start;padding:0.5rem 1rem;gap:0.25rem}.app-info-heading.svelte-177u10y{font-weight:700;color:var(--account-center-maximized-app-info-color, inherit)}.w100.svelte-177u10y{width:100%}a.svelte-177u10y{font-weight:700}.powered-by-container.svelte-177u10y{color:var(--text-color);padding:0.75rem}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function create_if_block_10(ctx) {
  let disconnectallconfirm;
  let current;
  disconnectallconfirm = new DisconnectAllConfirm({
    props: {
      onClose: (
        /*func*/
        ctx[22]
      ),
      onConfirm: (
        /*disconnectAllWallets*/
        ctx[13]
      )
    }
  });
  return {
    c() {
      create_component(disconnectallconfirm.$$.fragment);
    },
    m(target, anchor) {
      mount_component(disconnectallconfirm, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const disconnectallconfirm_changes = {};
      if (dirty[0] & /*disconnectConfirmModal*/
      4)
        disconnectallconfirm_changes.onClose = /*func*/
        ctx2[22];
      disconnectallconfirm.$set(disconnectallconfirm_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(disconnectallconfirm.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(disconnectallconfirm.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(disconnectallconfirm, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let enabletransactionprotection;
  let current;
  enabletransactionprotection = new EnableTransactionProtection({
    props: {
      onDismiss: (
        /*func_1*/
        ctx[23]
      ),
      onEnable: (
        /*func_2*/
        ctx[24]
      )
    }
  });
  return {
    c() {
      create_component(enabletransactionprotection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(enabletransactionprotection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const enabletransactionprotection_changes = {};
      if (dirty[0] & /*enableTransactionProtection*/
      16)
        enabletransactionprotection_changes.onDismiss = /*func_1*/
        ctx2[23];
      enabletransactionprotection.$set(enabletransactionprotection_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(enabletransactionprotection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(enabletransactionprotection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(enabletransactionprotection, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let div12;
  let div11;
  let div2;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div1;
  let t1;
  let div8;
  let div7;
  let div3;
  let walletappbadge;
  let t2;
  let t3;
  let div6;
  let div4;
  let t4_value = (
    /*$_*/
    ctx[9]("accountCenter.currentNetwork", { default: en.accountCenter.currentNetwork }) + ""
  );
  let t4;
  let t5;
  let div5;
  let networkselector;
  let t6;
  let t7;
  let div10;
  let t8;
  let t9;
  let div9;
  let a;
  let div12_transition;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$wallets$*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*wallet*/
    ctx2[29].label
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  let if_block0 = (
    /*device*/
    ctx[17].type === "desktop" && create_if_block_8(ctx)
  );
  walletappbadge = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "custom",
      color: !/*validAppChain*/
      ctx[5] ? "#FFAF00" : !/*validAppChain*/
      ctx[5].icon ? "#EFF1FC" : void 0,
      customBackgroundColor: (
        /*validAppChain*/
        ctx[5] ? (
          /*validAppChain*/
          ctx[5].color || /*defaultChainStyles*/
          ctx[7] && /*defaultChainStyles*/
          ctx[7].color || unrecognizedChainStyle.color
        ) : "#FFE7B3"
      ),
      border: "transparent",
      radius: 8,
      icon: (
        /*validAppChain*/
        ctx[5] ? (
          /*validAppChain*/
          ctx[5].icon || /*defaultChainStyles*/
          ctx[7] && /*defaultChainStyles*/
          ctx[7].icon || unrecognizedChainStyle.icon
        ) : warningIcon
      )
    }
  });
  let if_block1 = (
    /*validAppChain*/
    ctx[5] && create_if_block_7()
  );
  networkselector = new NetworkSelector({
    props: {
      chains: (
        /*appChains*/
        ctx[14]
      ),
      colorVar: "--account-center-maximized-network-selector-color",
      bold: true,
      selectIcon: caretLightIcon,
      parentCSSId: "maximized_ac"
    }
  });
  let if_block2 = !/*$accountCenter$*/
  ctx[10].hideTransactionProtectionBtn && /*primaryWalletOnMainnet*/
  ctx[6] && create_if_block_6(ctx);
  let if_block3 = (
    /*$appMetadata$*/
    ctx[11] && create_if_block_2$1(ctx)
  );
  let if_block4 = (
    /*secondaryTokens*/
    ctx[8] && /*secondaryTokens*/
    ctx[8].length && create_if_block_1$1(ctx)
  );
  return {
    c() {
      div12 = element("div");
      div11 = element("div");
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      div8 = element("div");
      div7 = element("div");
      div3 = element("div");
      create_component(walletappbadge.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div6 = element("div");
      div4 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div5 = element("div");
      create_component(networkselector.$$.fragment);
      t6 = space();
      if (if_block2)
        if_block2.c();
      t7 = space();
      div10 = element("div");
      if (if_block3)
        if_block3.c();
      t8 = space();
      if (if_block4)
        if_block4.c();
      t9 = space();
      div9 = element("div");
      a = element("a");
      attr(div0, "class", "wallets svelte-177u10y");
      attr(div1, "class", "actions flex flex-column items-start svelte-177u10y");
      attr(div2, "class", "p5 svelte-177u10y");
      attr(div3, "class", "relative flex");
      attr(div4, "class", "network-selector-label svelte-177u10y");
      attr(div5, "class", "flex items-center");
      set_style(div5, "width", "100%");
      attr(div6, "class", "network-selector-container svelte-177u10y");
      attr(div7, "class", "network-section flex items-center svelte-177u10y");
      attr(div8, "class", "network-container svelte-177u10y");
      toggle_class(
        div8,
        "background-blue",
        /*validAppChain*/
        ctx[5] && /*validAppChain*/
        ctx[5].icon || /*defaultChainStyles*/
        ctx[7]
      );
      toggle_class(div8, "background-yellow", !/*validAppChain*/
      ctx[5]);
      toggle_class(
        div8,
        "background-gray",
        /*validAppChain*/
        ctx[5] && !/*defaultChainStyles*/
        ctx[7]
      );
      attr(a, "href", "https://blocknative.com");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(a, "class", "flex justify-center items-center powered-by-container svelte-177u10y");
      attr(div9, "class", "w100 svelte-177u10y");
      attr(div10, "class", "app-info-container svelte-177u10y");
      attr(div11, "class", "wallets-section svelte-177u10y");
      attr(div12, "class", "outer-container svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div11);
      append(div11, div2);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div11, t1);
      append(div11, div8);
      append(div8, div7);
      append(div7, div3);
      mount_component(walletappbadge, div3, null);
      append(div3, t2);
      if (if_block1)
        if_block1.m(div3, null);
      append(div7, t3);
      append(div7, div6);
      append(div6, div4);
      append(div4, t4);
      append(div6, t5);
      append(div6, div5);
      mount_component(networkselector, div5, null);
      append(div8, t6);
      if (if_block2)
        if_block2.m(div8, null);
      append(div11, t7);
      append(div11, div10);
      if (if_block3)
        if_block3.m(div10, null);
      append(div10, t8);
      if (if_block4)
        if_block4.m(div10, null);
      append(div10, t9);
      append(div10, div9);
      append(div9, a);
      a.innerHTML = poweredByBlocknative;
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div5,
            "click",
            /*click_handler*/
            ctx[21]
          ),
          listen(div12, "click", stop_propagation(function() {
            if (is_function(
              /*hideWalletRowMenu*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$wallets$, hideWalletRowMenu*/
      10) {
        each_value = /*$wallets$*/
        ctx[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (
        /*device*/
        ctx[17].type === "desktop"
      )
        if_block0.p(ctx, dirty);
      const walletappbadge_changes = {};
      if (dirty[0] & /*validAppChain*/
      32)
        walletappbadge_changes.color = !/*validAppChain*/
        ctx[5] ? "#FFAF00" : !/*validAppChain*/
        ctx[5].icon ? "#EFF1FC" : void 0;
      if (dirty[0] & /*validAppChain, defaultChainStyles*/
      160)
        walletappbadge_changes.customBackgroundColor = /*validAppChain*/
        ctx[5] ? (
          /*validAppChain*/
          ctx[5].color || /*defaultChainStyles*/
          ctx[7] && /*defaultChainStyles*/
          ctx[7].color || unrecognizedChainStyle.color
        ) : "#FFE7B3";
      if (dirty[0] & /*validAppChain, defaultChainStyles*/
      160)
        walletappbadge_changes.icon = /*validAppChain*/
        ctx[5] ? (
          /*validAppChain*/
          ctx[5].icon || /*defaultChainStyles*/
          ctx[7] && /*defaultChainStyles*/
          ctx[7].icon || unrecognizedChainStyle.icon
        ) : warningIcon;
      walletappbadge.$set(walletappbadge_changes);
      if (
        /*validAppChain*/
        ctx[5]
      ) {
        if (if_block1) {
          if (dirty[0] & /*validAppChain*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_7();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*$_*/
      512) && t4_value !== (t4_value = /*$_*/
      ctx[9]("accountCenter.currentNetwork", { default: en.accountCenter.currentNetwork }) + ""))
        set_data(t4, t4_value);
      if (!/*$accountCenter$*/
      ctx[10].hideTransactionProtectionBtn && /*primaryWalletOnMainnet*/
      ctx[6]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_6(ctx);
          if_block2.c();
          if_block2.m(div8, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & /*validAppChain, defaultChainStyles*/
      160) {
        toggle_class(
          div8,
          "background-blue",
          /*validAppChain*/
          ctx[5] && /*validAppChain*/
          ctx[5].icon || /*defaultChainStyles*/
          ctx[7]
        );
      }
      if (!current || dirty[0] & /*validAppChain*/
      32) {
        toggle_class(div8, "background-yellow", !/*validAppChain*/
        ctx[5]);
      }
      if (!current || dirty[0] & /*validAppChain, defaultChainStyles*/
      160) {
        toggle_class(
          div8,
          "background-gray",
          /*validAppChain*/
          ctx[5] && !/*defaultChainStyles*/
          ctx[7]
        );
      }
      if (
        /*$appMetadata$*/
        ctx[11]
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty[0] & /*$appMetadata$*/
          2048) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$1(ctx);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div10, t8);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*secondaryTokens*/
        ctx[8] && /*secondaryTokens*/
        ctx[8].length
      ) {
        if (if_block4) {
          if_block4.p(ctx, dirty);
          if (dirty[0] & /*secondaryTokens*/
          256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$1(ctx);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div10, t9);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(walletappbadge.$$.fragment, local);
      transition_in(if_block1);
      transition_in(networkselector.$$.fragment, local);
      transition_in(if_block3);
      transition_in(if_block4);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div12_transition)
            div12_transition = create_bidirectional_transition(
              div12,
              fly,
              {
                duration: 600,
                y: (
                  /*position*/
                  ctx[16].includes("bottom") ? 56 : -76
                ),
                easing: quartOut,
                opacity: 0
              },
              true
            );
          div12_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(walletappbadge.$$.fragment, local);
      transition_out(if_block1);
      transition_out(networkselector.$$.fragment, local);
      transition_out(if_block3);
      transition_out(if_block4);
      if (local) {
        if (!div12_transition)
          div12_transition = create_bidirectional_transition(
            div12,
            fly,
            {
              duration: 600,
              y: (
                /*position*/
                ctx[16].includes("bottom") ? 56 : -76
              ),
              easing: quartOut,
              opacity: 0
            },
            false
          );
        div12_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block0)
        if_block0.d();
      destroy_component(walletappbadge);
      if (if_block1)
        if_block1.d();
      destroy_component(networkselector);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (detaching && div12_transition)
        div12_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let walletrow;
  let updating_hideMenu;
  let current;
  function walletrow_hideMenu_binding(value) {
    ctx[25](value);
  }
  let walletrow_props = {
    wallet: (
      /*wallet*/
      ctx[29]
    ),
    primary: (
      /*i*/
      ctx[31] === 0
    )
  };
  if (
    /*hideWalletRowMenu*/
    ctx[3] !== void 0
  ) {
    walletrow_props.hideMenu = /*hideWalletRowMenu*/
    ctx[3];
  }
  walletrow = new WalletRow({ props: walletrow_props });
  binding_callbacks.push(() => bind(walletrow, "hideMenu", walletrow_hideMenu_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(walletrow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(walletrow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const walletrow_changes = {};
      if (dirty[0] & /*$wallets$*/
      2)
        walletrow_changes.wallet = /*wallet*/
        ctx[29];
      if (dirty[0] & /*$wallets$*/
      2)
        walletrow_changes.primary = /*i*/
        ctx[31] === 0;
      if (!updating_hideMenu && dirty[0] & /*hideWalletRowMenu*/
      8) {
        updating_hideMenu = true;
        walletrow_changes.hideMenu = /*hideWalletRowMenu*/
        ctx[3];
        add_flush_callback(() => updating_hideMenu = false);
      }
      walletrow.$set(walletrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(walletrow, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let div1;
  let div0;
  let t0;
  let span0;
  let t1_value = (
    /*$_*/
    ctx[9]("accountCenter.connectAnotherWallet", {
      default: en.accountCenter.connectAnotherWallet
    }) + ""
  );
  let t1;
  let t2;
  let div3;
  let div2;
  let t3;
  let span1;
  let t4_value = (
    /*$_*/
    ctx[9]("accountCenter.disconnectAllWallets", {
      default: en.accountCenter.disconnectAllWallets
    }) + ""
  );
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(div0, "class", "plus-icon flex items-center justify-center svelte-177u10y");
      attr(span0, "class", "action-text svelte-177u10y");
      attr(div1, "class", "action-container flex items-center pointer svelte-177u10y");
      attr(div2, "class", "arrow-forward flex items-center justify-center svelte-177u10y");
      attr(span1, "class", "action-text svelte-177u10y");
      attr(div3, "class", "action-container flex items-center mt pointer svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      div0.innerHTML = plusCircleIcon;
      append(div1, t0);
      append(div1, span0);
      append(span0, t1);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      div2.innerHTML = arrowForwardIcon;
      append(div3, t3);
      append(div3, span1);
      append(span1, t4);
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "click",
            /*click_handler_1*/
            ctx[26]
          ),
          listen(
            div3,
            "click",
            /*click_handler_2*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      512 && t1_value !== (t1_value = /*$_*/
      ctx2[9]("accountCenter.connectAnotherWallet", {
        default: en.accountCenter.connectAnotherWallet
      }) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*$_*/
      512 && t4_value !== (t4_value = /*$_*/
      ctx2[9]("accountCenter.disconnectAllWallets", {
        default: en.accountCenter.disconnectAllWallets
      }) + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let successstatusicon;
  let current;
  successstatusicon = new SuccessStatusIcon({ props: { size: 14 } });
  return {
    c() {
      div = element("div");
      create_component(successstatusicon.$$.fragment);
      set_style(div, "right", "-5px");
      set_style(div, "bottom", "-5px");
      attr(div, "class", "drop-shadow absolute");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(successstatusicon, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(successstatusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(successstatusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(successstatusicon);
    }
  };
}
function create_if_block_6(ctx) {
  let div1;
  let div0;
  let t0;
  let span;
  let t1_value = (
    /*$_*/
    ctx[9]("accountCenter.enableTransactionProtection", {
      default: en.accountCenter.enableTransactionProtection
    }) + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(div0, "class", "shield svelte-177u10y");
      attr(span, "class", "protect-text svelte-177u10y");
      attr(div1, "class", "protect action-container flex items-center pointer svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      div0.innerHTML = shieldIcon;
      append(div1, t0);
      append(div1, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          div1,
          "click",
          /*click_handler_3*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      512 && t1_value !== (t1_value = /*$_*/
      ctx2[9]("accountCenter.enableTransactionProtection", {
        default: en.accountCenter.enableTransactionProtection
      }) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$1(ctx) {
  let div3;
  let div1;
  let walletappbadge;
  let t0;
  let div0;
  let t1_value = (
    /*$appMetadata$*/
    (ctx[11] && /*$appMetadata$*/
    ctx[11].name || "App Name") + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*$appMetadata$*/
    (ctx[11] && /*$appMetadata$*/
    ctx[11].description || "This app has not added a description.") + ""
  );
  let t3;
  let t4;
  let if_block_anchor;
  let current;
  walletappbadge = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "white",
      border: "black",
      radius: 8,
      icon: (
        /*$appMetadata$*/
        ctx[11] && /*$appMetadata$*/
        ctx[11].icon || questionIcon
      )
    }
  });
  let if_block = (
    /*$appMetadata$*/
    (ctx[11].gettingStartedGuide || /*$appMetadata$*/
    ctx[11].explore) && create_if_block_3(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      create_component(walletappbadge.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "app-name svelte-177u10y");
      attr(div1, "class", "relative flex app-icon-name svelte-177u10y");
      attr(div2, "class", "app-description svelte-177u10y");
      attr(div3, "class", "flex items-start app-info-header svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      mount_component(walletappbadge, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      insert(target, t4, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const walletappbadge_changes = {};
      if (dirty[0] & /*$appMetadata$*/
      2048)
        walletappbadge_changes.icon = /*$appMetadata$*/
        ctx2[11] && /*$appMetadata$*/
        ctx2[11].icon || questionIcon;
      walletappbadge.$set(walletappbadge_changes);
      if ((!current || dirty[0] & /*$appMetadata$*/
      2048) && t1_value !== (t1_value = /*$appMetadata$*/
      (ctx2[11] && /*$appMetadata$*/
      ctx2[11].name || "App Name") + ""))
        set_data(t1, t1_value);
      if ((!current || dirty[0] & /*$appMetadata$*/
      2048) && t3_value !== (t3_value = /*$appMetadata$*/
      (ctx2[11] && /*$appMetadata$*/
      ctx2[11].description || "This app has not added a description.") + ""))
        set_data(t3, t3_value);
      if (
        /*$appMetadata$*/
        ctx2[11].gettingStartedGuide || /*$appMetadata$*/
        ctx2[11].explore
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(walletappbadge);
      if (detaching)
        detach(t4);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*$_*/
    ctx[9]("accountCenter.appInfo", { default: en.accountCenter.appInfo }) + ""
  );
  let t0;
  let t1;
  let t2;
  let if_block0 = (
    /*$appMetadata$*/
    ctx[11].gettingStartedGuide && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*$appMetadata$*/
    ctx[11].explore && create_if_block_4(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "app-info-heading svelte-177u10y");
      attr(div1, "class", "app-info svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      512 && t0_value !== (t0_value = /*$_*/
      ctx2[9]("accountCenter.appInfo", { default: en.accountCenter.appInfo }) + ""))
        set_data(t0, t0_value);
      if (
        /*$appMetadata$*/
        ctx2[11].gettingStartedGuide
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(div1, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$appMetadata$*/
        ctx2[11].explore
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_5(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*$_*/
    ctx[9]("accountCenter.learnMore", { default: en.accountCenter.learnMore }) + ""
  );
  let t0;
  let t1;
  let a;
  let t2_value = (
    /*$_*/
    ctx[9]("accountCenter.gettingStartedGuide", {
      default: en.accountCenter.gettingStartedGuide
    }) + ""
  );
  let t2;
  let a_href_value;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text(t2_value);
      attr(a, "href", a_href_value = /*$appMetadata$*/
      ctx[11].gettingStartedGuide);
      attr(a, "target", "_blank");
      attr(a, "rel", "noreferrer noopener");
      attr(a, "class", "svelte-177u10y");
      attr(div1, "class", "flex justify-between items-center w100 svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      512 && t0_value !== (t0_value = /*$_*/
      ctx2[9]("accountCenter.learnMore", { default: en.accountCenter.learnMore }) + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$_*/
      512 && t2_value !== (t2_value = /*$_*/
      ctx2[9]("accountCenter.gettingStartedGuide", {
        default: en.accountCenter.gettingStartedGuide
      }) + ""))
        set_data(t2, t2_value);
      if (dirty[0] & /*$appMetadata$*/
      2048 && a_href_value !== (a_href_value = /*$appMetadata$*/
      ctx2[11].gettingStartedGuide)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_4(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*$_*/
    ctx[9]("accountCenter.smartContracts", { default: en.accountCenter.smartContracts }) + ""
  );
  let t0;
  let t1;
  let a;
  let t2_value = (
    /*$_*/
    ctx[9]("accountCenter.explore", { default: en.accountCenter.explore }) + ""
  );
  let t2;
  let a_href_value;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text(t2_value);
      attr(a, "href", a_href_value = /*$appMetadata$*/
      ctx[11].explore);
      attr(a, "target", "_blank");
      attr(a, "rel", "noreferrer noopener");
      attr(a, "class", "svelte-177u10y");
      attr(div1, "class", "flex justify-between items-center w100 svelte-177u10y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      512 && t0_value !== (t0_value = /*$_*/
      ctx2[9]("accountCenter.smartContracts", { default: en.accountCenter.smartContracts }) + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$_*/
      512 && t2_value !== (t2_value = /*$_*/
      ctx2[9]("accountCenter.explore", { default: en.accountCenter.explore }) + ""))
        set_data(t2, t2_value);
      if (dirty[0] & /*$appMetadata$*/
      2048 && a_href_value !== (a_href_value = /*$appMetadata$*/
      ctx2[11].explore)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_1$1(ctx) {
  let secondarytokentable;
  let current;
  secondarytokentable = new SecondaryTokenTable({
    props: {
      secondaryTokens: (
        /*secondaryTokens*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(secondarytokentable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(secondarytokentable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const secondarytokentable_changes = {};
      if (dirty[0] & /*secondaryTokens*/
      256)
        secondarytokentable_changes.secondaryTokens = /*secondaryTokens*/
        ctx2[8];
      secondarytokentable.$set(secondarytokentable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(secondarytokentable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(secondarytokentable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(secondarytokentable, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*disconnectConfirmModal*/
    ctx[2] && create_if_block_10(ctx)
  );
  let if_block1 = (
    /*enableTransactionProtection*/
    ctx[4] && create_if_block_9(ctx)
  );
  let if_block2 = (
    /*expanded*/
    ctx[0] && create_if_block$2(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*disconnectConfirmModal*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*disconnectConfirmModal*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*enableTransactionProtection*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*enableTransactionProtection*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*expanded*/
        ctx2[0]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*expanded*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let primaryWallet;
  let connectedChain;
  let secondaryTokens;
  let validAppChain;
  let defaultChainStyles;
  let primaryWalletOnMainnet;
  let $wallets$;
  let $_;
  let $accountCenter$;
  let $appMetadata$;
  component_subscribe($$self, wallets$, ($$value) => $$invalidate(1, $wallets$ = $$value));
  component_subscribe($$self, $format, ($$value) => $$invalidate(9, $_ = $$value));
  let { expanded } = $$props;
  const accountCenter$ = state$1.select("accountCenter").pipe(startWith(state$1.get().accountCenter), shareReplay(1));
  component_subscribe($$self, accountCenter$, (value) => $$invalidate(10, $accountCenter$ = value));
  function disconnectAllWallets() {
    $wallets$.forEach(({ label }) => disconnect({ label }));
  }
  const { chains: appChains } = state$1.get();
  let disconnectConfirmModal = false;
  let hideWalletRowMenu;
  let enableTransactionProtection = false;
  const appMetadata$ = state$1.select("appMetadata").pipe(startWith(state$1.get().appMetadata), shareReplay(1));
  component_subscribe($$self, appMetadata$, (value) => $$invalidate(11, $appMetadata$ = value));
  const { position } = state$1.get().accountCenter;
  const { device } = configuration;
  const enableProtectionRPC = async () => {
    try {
      await updateChainRPC(primaryWallet.provider, validAppChain, BN_PROTECT_RPC_URL);
      $$invalidate(4, enableTransactionProtection = false);
    } catch (error) {
      const { code } = error;
      console.log(error, code);
    }
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const func = () => $$invalidate(2, disconnectConfirmModal = false);
  const func_1 = () => $$invalidate(4, enableTransactionProtection = false);
  const func_2 = () => enableProtectionRPC();
  function walletrow_hideMenu_binding(value) {
    hideWalletRowMenu = value;
    $$invalidate(3, hideWalletRowMenu);
  }
  const click_handler_1 = () => connect$1();
  const click_handler_2 = () => $$invalidate(2, disconnectConfirmModal = true);
  const click_handler_3 = () => $$invalidate(4, enableTransactionProtection = true);
  $$self.$$set = ($$props2) => {
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$wallets$*/
    2) {
      $$invalidate(19, [primaryWallet] = $wallets$, primaryWallet);
    }
    if ($$self.$$.dirty[0] & /*primaryWallet*/
    524288) {
      $$invalidate(20, [connectedChain] = primaryWallet ? primaryWallet.chains : [], connectedChain);
    }
    if ($$self.$$.dirty[0] & /*primaryWallet*/
    524288) {
      $$invalidate(8, secondaryTokens = primaryWallet && primaryWallet.accounts.length && primaryWallet.accounts[0].secondaryTokens);
    }
    if ($$self.$$.dirty[0] & /*connectedChain*/
    1048576) {
      $$invalidate(5, validAppChain = appChains.find(({ id, namespace }) => connectedChain ? id === connectedChain.id && namespace === connectedChain.namespace : false));
    }
    if ($$self.$$.dirty[0] & /*connectedChain*/
    1048576) {
      $$invalidate(7, defaultChainStyles = getDefaultChainStyles(connectedChain && connectedChain.id));
    }
    if ($$self.$$.dirty[0] & /*connectedChain*/
    1048576) {
      $$invalidate(6, primaryWalletOnMainnet = connectedChain && connectedChain.id === "0x1");
    }
  };
  return [
    expanded,
    $wallets$,
    disconnectConfirmModal,
    hideWalletRowMenu,
    enableTransactionProtection,
    validAppChain,
    primaryWalletOnMainnet,
    defaultChainStyles,
    secondaryTokens,
    $_,
    $accountCenter$,
    $appMetadata$,
    accountCenter$,
    disconnectAllWallets,
    appChains,
    appMetadata$,
    position,
    device,
    enableProtectionRPC,
    primaryWallet,
    connectedChain,
    click_handler,
    func,
    func_1,
    func_2,
    walletrow_hideMenu_binding,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
var AccountCenterPanel = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$3, create_fragment$3, safe_not_equal, { expanded: 0 }, add_css$3, [-1, -1]);
  }
};
function add_css$2(target) {
  append_styles(target, "svelte-1xsvwqj", ".ac-trigger.svelte-1xsvwqj{--background-color:var(\n      --account-center-minimized-background,\n      var(--w3o-background-color, white)\n    );--text-color:var(--w3o-text-color, var(--gray-700));--border-color:var(\n      --account-center-border,\n      var(--w3o-border-color, var(--onboard-gray-200, var(--gray-200)))\n    );--border-radius:var(\n      --account-center-border-radius,\n      var(--w3o-border-radius, 1rem)\n    );cursor:pointer;pointer-events:auto;width:100%;padding:0.5rem;border:1px solid;background:var(--background-color);color:var(--text-color);border-color:var(--border-color);border-radius:var(--border-radius);box-shadow:var(\n      --account-center-box-shadow,\n      var(--onboard-shadow-3, var(--shadow-3))\n    );z-index:var(--account-center-z-index, 1)}.inner-row.svelte-1xsvwqj{display:flex;flex-flow:row nowrap;align-items:center;gap:0.5rem;padding:0 0.25rem}.wallet-info.svelte-1xsvwqj{display:flex;flex:1;flex-flow:column;height:2.5rem;overflow:hidden}.address.svelte-1xsvwqj{font-weight:600;line-height:1.25rem;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;color:var(--account-center-minimized-address-color, inherit)}.balance.svelte-1xsvwqj{font-weight:400;line-height:1.25rem;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;opacity:0.6;color:var(--account-center-minimized-balance-color, inherit)}.chain-icon-container.svelte-1xsvwqj{margin-right:4px}.container.svelte-1xsvwqj{border:1px solid transparent;border-radius:16px;padding:1px;transition:border-color 250ms ease-in-out, backround 250ms ease-in-out;max-width:128px;cursor:default}.drop-shadow.svelte-1xsvwqj{filter:drop-shadow(0px 1px 4px rgba(0, 0, 0, 0.2))}");
}
function create_if_block$1(ctx) {
  let div;
  let t0_value = (
    /*firstAddressBalance*/
    (ctx[5].length > 7 ? (
      /*firstAddressBalance*/
      ctx[5].slice(0, 7)
    ) : (
      /*firstAddressBalance*/
      ctx[5]
    )) + ""
  );
  let t0;
  let t1;
  let t2;
  let div_intro;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(
        /*firstAddressAsset*/
        ctx[2]
      );
      attr(div, "class", "balance svelte-1xsvwqj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*firstAddressBalance*/
      32 && t0_value !== (t0_value = /*firstAddressBalance*/
      (ctx2[5].length > 7 ? (
        /*firstAddressBalance*/
        ctx2[5].slice(0, 7)
      ) : (
        /*firstAddressBalance*/
        ctx2[5]
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*firstAddressAsset*/
      4)
        set_data(
          t2,
          /*firstAddressAsset*/
          ctx2[2]
        );
    },
    i(local) {
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, fade, {});
            div_intro.start();
          });
        }
      }
    },
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2(ctx) {
  let div11;
  let div10;
  let div3;
  let div0;
  let walletappbadge0;
  let t0;
  let div1;
  let walletappbadge1;
  let t1;
  let div2;
  let successstatusicon;
  let t2;
  let div5;
  let div4;
  let t3_value = (
    /*ensName*/
    (ctx[8] ? shortenDomain(
      /*ensName*/
      ctx[8]
    ) : (
      /*unsName*/
      ctx[7] ? shortenDomain(
        /*unsName*/
        ctx[7]
      ) : (
        /*shortenedFirstAddress*/
        ctx[6]
      )
    )) + ""
  );
  let t3;
  let t4;
  let t5;
  let div9;
  let div8;
  let div7;
  let div6;
  let walletappbadge2;
  let t6;
  let networkselector;
  let div8_style_value;
  let div11_intro;
  let div11_outro;
  let current;
  let mounted;
  let dispose;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "white",
      border: "darkGreen",
      radius: 8,
      icon: (
        /*$appMetadata$*/
        ctx[9] && /*$appMetadata$*/
        ctx[9].icon || questionIcon
      )
    }
  });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "green",
      border: "darkGreen",
      radius: 8,
      icon: (
        /*primaryWallet*/
        ctx[1] ? (
          /*primaryWallet*/
          ctx[1].icon
        ) : ""
      )
    }
  });
  successstatusicon = new SuccessStatusIcon({ props: { size: 14 } });
  let if_block = (
    /*firstAddressBalance*/
    ctx[5] && create_if_block$1(ctx)
  );
  walletappbadge2 = new WalletAppBadge({
    props: {
      size: 22,
      padding: 4,
      background: "custom",
      color: !/*validAppChain*/
      ctx[4] ? `var(
                    --account-center-chain-warning,
                    var(--onboard-warning-500, var(--warning-500))
                  )` : !/*validAppChain*/
      ctx[4].icon ? `var(--onboard-primary-100, var(--primary-100))` : void 0,
      customBackgroundColor: (
        /*validAppChain*/
        ctx[4] ? (
          /*validAppChain*/
          ctx[4].color || /*defaultChainStyles*/
          ctx[3] && /*defaultChainStyles*/
          ctx[3].color || unrecognizedChainStyle.color
        ) : `var(--onboard-warning-200, var(--warning-200))`
      ),
      border: "transparent",
      radius: 25,
      icon: (
        /*validAppChain*/
        ctx[4] ? (
          /*validAppChain*/
          ctx[4].icon || /*defaultChainStyles*/
          ctx[3] && /*defaultChainStyles*/
          ctx[3].icon || unrecognizedChainStyle.icon
        ) : warningIcon
      )
    }
  });
  networkselector = new NetworkSelector({
    props: {
      chains: (
        /*chains*/
        ctx[11]
      ),
      colorVar: "--account-center-minimized-network-selector-color",
      selectIcon: caretIcon,
      parentCSSId: "minimized_ac"
    }
  });
  return {
    c() {
      div11 = element("div");
      div10 = element("div");
      div3 = element("div");
      div0 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t1 = space();
      div2 = element("div");
      create_component(successstatusicon.$$.fragment);
      t2 = space();
      div5 = element("div");
      div4 = element("div");
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      div9 = element("div");
      div8 = element("div");
      div7 = element("div");
      div6 = element("div");
      create_component(walletappbadge2.$$.fragment);
      t6 = space();
      create_component(networkselector.$$.fragment);
      attr(div0, "class", "drop-shadow svelte-1xsvwqj");
      set_style(div1, "margin-left", "-0.5rem");
      attr(div1, "class", "drop-shadow svelte-1xsvwqj");
      set_style(div2, "right", "-4px");
      set_style(div2, "bottom", "-4px");
      attr(div2, "class", "drop-shadow absolute svelte-1xsvwqj");
      attr(div3, "class", "flex relative");
      attr(div4, "class", "address svelte-1xsvwqj");
      attr(div5, "class", "wallet-info svelte-1xsvwqj");
      attr(div6, "class", "chain-icon-container svelte-1xsvwqj");
      attr(div7, "class", "flex items-center");
      attr(div8, "class", "container shadow-1 flex items-center svelte-1xsvwqj");
      attr(div8, "style", div8_style_value = `border-color: var(${/*validAppChain*/
      ctx[4] ? "--onboard-primary-200, var(--primary-200)" : "--onboard-warning-500, var(--warning-500)"}); background-color: var(${/*validAppChain*/
      ctx[4] ? "--account-center-minimized-chain-select-background, var(--primary-100)" : "--account-center-minimized-chain-select-background-warning, var(--warning-100)"})`);
      attr(div9, "class", "network");
      attr(div10, "class", "inner-row svelte-1xsvwqj");
      attr(div11, "class", "ac-trigger svelte-1xsvwqj");
    },
    m(target, anchor) {
      insert(target, div11, anchor);
      append(div11, div10);
      append(div10, div3);
      append(div3, div0);
      mount_component(walletappbadge0, div0, null);
      append(div3, t0);
      append(div3, div1);
      mount_component(walletappbadge1, div1, null);
      append(div3, t1);
      append(div3, div2);
      mount_component(successstatusicon, div2, null);
      append(div10, t2);
      append(div10, div5);
      append(div5, div4);
      append(div4, t3);
      append(div5, t4);
      if (if_block)
        if_block.m(div5, null);
      append(div10, t5);
      append(div10, div9);
      append(div9, div8);
      append(div8, div7);
      append(div7, div6);
      mount_component(walletappbadge2, div6, null);
      append(div7, t6);
      mount_component(networkselector, div7, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div8, "click", stop_propagation(
            /*click_handler*/
            ctx[15]
          )),
          listen(div11, "click", stop_propagation(function() {
            if (is_function(
              /*toggle*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const walletappbadge0_changes = {};
      if (dirty & /*$appMetadata$*/
      512)
        walletappbadge0_changes.icon = /*$appMetadata$*/
        ctx[9] && /*$appMetadata$*/
        ctx[9].icon || questionIcon;
      walletappbadge0.$set(walletappbadge0_changes);
      const walletappbadge1_changes = {};
      if (dirty & /*primaryWallet*/
      2)
        walletappbadge1_changes.icon = /*primaryWallet*/
        ctx[1] ? (
          /*primaryWallet*/
          ctx[1].icon
        ) : "";
      walletappbadge1.$set(walletappbadge1_changes);
      if ((!current || dirty & /*ensName, unsName, shortenedFirstAddress*/
      448) && t3_value !== (t3_value = /*ensName*/
      (ctx[8] ? shortenDomain(
        /*ensName*/
        ctx[8]
      ) : (
        /*unsName*/
        ctx[7] ? shortenDomain(
          /*unsName*/
          ctx[7]
        ) : (
          /*shortenedFirstAddress*/
          ctx[6]
        )
      )) + ""))
        set_data(t3, t3_value);
      if (
        /*firstAddressBalance*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*firstAddressBalance*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const walletappbadge2_changes = {};
      if (dirty & /*validAppChain*/
      16)
        walletappbadge2_changes.color = !/*validAppChain*/
        ctx[4] ? `var(
                    --account-center-chain-warning,
                    var(--onboard-warning-500, var(--warning-500))
                  )` : !/*validAppChain*/
        ctx[4].icon ? `var(--onboard-primary-100, var(--primary-100))` : void 0;
      if (dirty & /*validAppChain, defaultChainStyles*/
      24)
        walletappbadge2_changes.customBackgroundColor = /*validAppChain*/
        ctx[4] ? (
          /*validAppChain*/
          ctx[4].color || /*defaultChainStyles*/
          ctx[3] && /*defaultChainStyles*/
          ctx[3].color || unrecognizedChainStyle.color
        ) : `var(--onboard-warning-200, var(--warning-200))`;
      if (dirty & /*validAppChain, defaultChainStyles*/
      24)
        walletappbadge2_changes.icon = /*validAppChain*/
        ctx[4] ? (
          /*validAppChain*/
          ctx[4].icon || /*defaultChainStyles*/
          ctx[3] && /*defaultChainStyles*/
          ctx[3].icon || unrecognizedChainStyle.icon
        ) : warningIcon;
      walletappbadge2.$set(walletappbadge2_changes);
      if (!current || dirty & /*validAppChain*/
      16 && div8_style_value !== (div8_style_value = `border-color: var(${/*validAppChain*/
      ctx[4] ? "--onboard-primary-200, var(--primary-200)" : "--onboard-warning-500, var(--warning-500)"}); background-color: var(${/*validAppChain*/
      ctx[4] ? "--account-center-minimized-chain-select-background, var(--primary-100)" : "--account-center-minimized-chain-select-background-warning, var(--warning-100)"})`)) {
        attr(div8, "style", div8_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      transition_in(successstatusicon.$$.fragment, local);
      transition_in(if_block);
      transition_in(walletappbadge2.$$.fragment, local);
      transition_in(networkselector.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div11_outro)
            div11_outro.end(1);
          div11_intro = create_in_transition(div11, fade, { duration: 250 });
          div11_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      transition_out(successstatusicon.$$.fragment, local);
      transition_out(walletappbadge2.$$.fragment, local);
      transition_out(networkselector.$$.fragment, local);
      if (div11_intro)
        div11_intro.invalidate();
      div11_outro = create_out_transition(div11, fade, { duration: 100 });
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div11);
      destroy_component(walletappbadge0);
      destroy_component(walletappbadge1);
      destroy_component(successstatusicon);
      if (if_block)
        if_block.d();
      destroy_component(walletappbadge2);
      destroy_component(networkselector);
      if (detaching && div11_outro)
        div11_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let primaryWallet;
  let firstAccount;
  let ensName;
  let unsName;
  let shortenedFirstAddress;
  let firstAddressAsset;
  let firstAddressBalance;
  let primaryChain;
  let validAppChain;
  let defaultChainStyles;
  let $wallets$;
  let $appMetadata$;
  component_subscribe($$self, wallets$, ($$value) => $$invalidate(14, $wallets$ = $$value));
  let { toggle } = $$props;
  const appMetadata$ = state$1.select("appMetadata").pipe(startWith(state$1.get().appMetadata), shareReplay(1));
  component_subscribe($$self, appMetadata$, (value) => $$invalidate(9, $appMetadata$ = value));
  const chains = state$1.get().chains;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("toggle" in $$props2)
      $$invalidate(0, toggle = $$props2.toggle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wallets$*/
    16384) {
      $$invalidate(1, [primaryWallet] = $wallets$, primaryWallet);
    }
    if ($$self.$$.dirty & /*primaryWallet*/
    2) {
      $$invalidate(13, [firstAccount] = primaryWallet ? primaryWallet.accounts : [], firstAccount);
    }
    if ($$self.$$.dirty & /*firstAccount*/
    8192) {
      $$invalidate(8, ensName = firstAccount && firstAccount.ens && shortenDomain(firstAccount.ens.name));
    }
    if ($$self.$$.dirty & /*firstAccount*/
    8192) {
      $$invalidate(7, unsName = firstAccount && firstAccount.uns && shortenDomain(firstAccount.uns.name));
    }
    if ($$self.$$.dirty & /*firstAccount*/
    8192) {
      $$invalidate(6, shortenedFirstAddress = firstAccount ? shortenAddress(firstAccount.address) : "");
    }
    if ($$self.$$.dirty & /*firstAccount*/
    8192) {
      $$invalidate(
        2,
        [firstAddressAsset] = firstAccount && firstAccount.balance ? Object.keys(firstAccount.balance) : [],
        firstAddressAsset
      );
    }
    if ($$self.$$.dirty & /*firstAccount, firstAddressAsset*/
    8196) {
      $$invalidate(5, firstAddressBalance = firstAccount && firstAccount.balance ? firstAccount.balance[firstAddressAsset] : null);
    }
    if ($$self.$$.dirty & /*primaryWallet*/
    2) {
      $$invalidate(12, primaryChain = primaryWallet && primaryWallet.chains[0]);
    }
    if ($$self.$$.dirty & /*primaryChain*/
    4096) {
      $$invalidate(4, validAppChain = chains.find(({ id, namespace }) => primaryChain ? id === primaryChain.id && namespace === primaryChain.namespace : false));
    }
    if ($$self.$$.dirty & /*primaryChain*/
    4096) {
      $$invalidate(3, defaultChainStyles = getDefaultChainStyles(primaryChain && primaryChain.id));
    }
  };
  return [
    toggle,
    primaryWallet,
    firstAddressAsset,
    defaultChainStyles,
    validAppChain,
    firstAddressBalance,
    shortenedFirstAddress,
    unsName,
    ensName,
    $appMetadata$,
    appMetadata$,
    chains,
    primaryChain,
    firstAccount,
    $wallets$,
    click_handler
  ];
}
var AcctCenterTriggerLarge = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { toggle: 0 }, add_css$2);
  }
};
function add_css$1(target) {
  append_styles(target, "svelte-1o9vinu", ".ac-trigger.svelte-1o9vinu{--background-color:var(\n      --account-center-minimized-background,\n      var(--w3o-background-color, white)\n    );--text-color:var(--w3o-text-color, var(--gray-700));--border-color:var(\n      --account-center-border,\n      var(--w3o-border-color, var(--onboard-gray-200, var(--gray-200)))\n    );--border-radius:var(\n      --account-center-border-radius,\n      var(--w3o-border-radius, 1rem)\n    );position:relative;cursor:pointer;pointer-events:auto;min-width:80px;background:var(--background-color);color:var(--text-color);border:1px solid var(--border-color);border-radius:var(--border-radius);box-shadow:var(\n      --account-center-box-shadow,\n      var(--onboard-shadow-3, var(--shadow-3))\n    );z-index:var(--account-center-z-index, 1)}.wallet-square-wrapper.svelte-1o9vinu{position:relative;margin-left:-8px}.check-icon-wrapper.svelte-1o9vinu{position:absolute;right:-4px;bottom:-4px}.inner-row.svelte-1o9vinu{display:flex;flex-flow:row nowrap;width:80px;padding:0.75rem}.drop-shadow.svelte-1o9vinu{filter:drop-shadow(0px 1px 4px rgba(0, 0, 0, 0.2))}");
}
function create_fragment$1(ctx) {
  let div5;
  let div4;
  let div0;
  let walletappbadge0;
  let t0;
  let div3;
  let div1;
  let walletappbadge1;
  let t1;
  let div2;
  let successstatusicon;
  let div5_style_value;
  let current;
  let mounted;
  let dispose;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "white",
      border: "darkGreen",
      radius: 8,
      icon: (
        /*$appMetadata$*/
        ctx[3] && /*$appMetadata$*/
        ctx[3].icon || questionIcon
      )
    }
  });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 32,
      padding: 4,
      background: "green",
      border: "darkGreen",
      radius: 8,
      icon: (
        /*primaryWallet*/
        ctx[1] ? (
          /*primaryWallet*/
          ctx[1].icon
        ) : ""
      )
    }
  });
  successstatusicon = new SuccessStatusIcon({ props: { size: 14 } });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t1 = space();
      div2 = element("div");
      create_component(successstatusicon.$$.fragment);
      attr(div0, "class", "drop-shadow svelte-1o9vinu");
      attr(div1, "class", "drop-shadow svelte-1o9vinu");
      attr(div2, "class", "check-icon-wrapper drop-shadow svelte-1o9vinu");
      attr(div3, "class", "wallet-square-wrapper svelte-1o9vinu");
      attr(div4, "class", "inner-row svelte-1o9vinu");
      attr(div5, "class", "ac-trigger svelte-1o9vinu");
      attr(div5, "style", div5_style_value = /*$accountCenter$*/
      ctx[2].position.includes("Left") ? "align-self: flex-start" : null);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      mount_component(walletappbadge0, div0, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      mount_component(walletappbadge1, div1, null);
      append(div3, t1);
      append(div3, div2);
      mount_component(successstatusicon, div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(div5, "click", stop_propagation(function() {
          if (is_function(
            /*toggle*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const walletappbadge0_changes = {};
      if (dirty & /*$appMetadata$*/
      8)
        walletappbadge0_changes.icon = /*$appMetadata$*/
        ctx[3] && /*$appMetadata$*/
        ctx[3].icon || questionIcon;
      walletappbadge0.$set(walletappbadge0_changes);
      const walletappbadge1_changes = {};
      if (dirty & /*primaryWallet*/
      2)
        walletappbadge1_changes.icon = /*primaryWallet*/
        ctx[1] ? (
          /*primaryWallet*/
          ctx[1].icon
        ) : "";
      walletappbadge1.$set(walletappbadge1_changes);
      if (!current || dirty & /*$accountCenter$*/
      4 && div5_style_value !== (div5_style_value = /*$accountCenter$*/
      ctx[2].position.includes("Left") ? "align-self: flex-start" : null)) {
        attr(div5, "style", div5_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      transition_in(successstatusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      transition_out(successstatusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(walletappbadge0);
      destroy_component(walletappbadge1);
      destroy_component(successstatusicon);
      mounted = false;
      dispose();
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let primaryWallet;
  let $wallets$;
  let $accountCenter$;
  let $appMetadata$;
  component_subscribe($$self, wallets$, ($$value) => $$invalidate(6, $wallets$ = $$value));
  let { toggle } = $$props;
  const appMetadata$ = state$1.select("appMetadata").pipe(startWith(state$1.get().appMetadata), shareReplay(1));
  component_subscribe($$self, appMetadata$, (value) => $$invalidate(3, $appMetadata$ = value));
  const accountCenter$ = state$1.select("accountCenter").pipe(startWith(state$1.get().accountCenter), shareReplay(1));
  component_subscribe($$self, accountCenter$, (value) => $$invalidate(2, $accountCenter$ = value));
  $$self.$$set = ($$props2) => {
    if ("toggle" in $$props2)
      $$invalidate(0, toggle = $$props2.toggle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wallets$*/
    64) {
      $$invalidate(1, [primaryWallet] = $wallets$, primaryWallet);
    }
  };
  return [
    toggle,
    primaryWallet,
    $accountCenter$,
    $appMetadata$,
    appMetadata$,
    accountCenter$,
    $wallets$
  ];
}
var AcctCenterTriggerSmall = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { toggle: 0 }, add_css$1);
  }
};
function add_css(target) {
  append_styles(target, "svelte-1nua59o", ".ac-container.svelte-1nua59o{display:flex;flex-flow:column;align-items:flex-end;gap:0.5rem}");
}
function create_if_block_2(ctx) {
  let accountcenterpanel;
  let current;
  accountcenterpanel = new AccountCenterPanel({ props: { expanded: (
    /*expanded*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(accountcenterpanel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accountcenterpanel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accountcenterpanel_changes = {};
      if (dirty & /*expanded*/
      1)
        accountcenterpanel_changes.expanded = /*expanded*/
        ctx2[0];
      accountcenterpanel.$set(accountcenterpanel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accountcenterpanel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accountcenterpanel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accountcenterpanel, detaching);
    }
  };
}
function create_else_block(ctx) {
  let triggerlarge;
  let current;
  triggerlarge = new AcctCenterTriggerLarge({ props: { toggle: (
    /*toggle*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(triggerlarge.$$.fragment);
    },
    m(target, anchor) {
      mount_component(triggerlarge, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(triggerlarge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(triggerlarge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(triggerlarge, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let triggersmall;
  let current;
  triggersmall = new AcctCenterTriggerSmall({ props: { toggle: (
    /*toggle*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(triggersmall.$$.fragment);
    },
    m(target, anchor) {
      mount_component(triggersmall, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(triggersmall.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(triggersmall.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(triggersmall, detaching);
    }
  };
}
function create_if_block(ctx) {
  let accountcenterpanel;
  let current;
  accountcenterpanel = new AccountCenterPanel({ props: { expanded: (
    /*expanded*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(accountcenterpanel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accountcenterpanel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accountcenterpanel_changes = {};
      if (dirty & /*expanded*/
      1)
        accountcenterpanel_changes.expanded = /*expanded*/
        ctx2[0];
      accountcenterpanel.$set(accountcenterpanel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accountcenterpanel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accountcenterpanel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accountcenterpanel, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let show_if_1 = (
    /*$accountCenter$*/
    ctx[1].position.includes("bottom")
  );
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let show_if = (
    /*$accountCenter$*/
    ctx[1].position.includes("top")
  );
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if_1 && create_if_block_2(ctx);
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$accountCenter$*/
      ctx2[1].minimal
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = show_if && create_if_block(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "ac-container svelte-1nua59o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "click",
          /*minimize*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$accountCenter$*/
      2)
        show_if_1 = /*$accountCenter$*/
        ctx2[1].position.includes("bottom");
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$accountCenter$*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (dirty & /*$accountCenter$*/
      2)
        show_if = /*$accountCenter$*/
        ctx2[1].position.includes("top");
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$accountCenter$*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $accountCenter$;
  let expanded = false;
  const accountCenter$ = state$1.select("accountCenter").pipe(startWith(state$1.get().accountCenter), shareReplay(1));
  component_subscribe($$self, accountCenter$, (value) => $$invalidate(1, $accountCenter$ = value));
  onDestroy(minimize);
  function minimize() {
    if ($accountCenter$.expanded) {
      updateAccountCenter({ expanded: false });
      $$invalidate(0, expanded = false);
    }
  }
  function toggle() {
    updateAccountCenter({ expanded: !$accountCenter$.expanded });
    $$invalidate(0, expanded = !expanded);
  }
  return [expanded, $accountCenter$, accountCenter$, minimize, toggle];
}
var Index = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
  }
};
export {
  Index as default
};
//# sourceMappingURL=Index-b9dc0f9d-CGEMT5BF.js.map
